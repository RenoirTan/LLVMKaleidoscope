var searchIndex = JSON.parse('{\
"filestream":{"doc":"","t":[5],"n":["main"],"q":["filestream"],"d":[""],"i":[0],"f":[[[]]],"p":[]},\
"kaleidoscope":{"doc":"This is the root page for my implementation of a parser …","t":[13,3,13,13,3,13,3,8,13,8,8,13,13,3,13,8,3,13,6,3,6,13,3,3,4,3,13,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,12,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,12,11,11,11,11,11,12,11,11,12,12,11,11,11,12,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,14,14,11,11,11,11,11,11,11,11,11,11,11,11,11,14,14,12,11,12,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,12,12,12,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,10,10,0,12,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,12,11,11,12,12,11,11,10,10,11,11,11,11,11,12,12,12,11,11,11,11,11,11,11,11,11,11,11,11,11,11,12,12,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,14,11,12,3,13,13,3,3,6,3,3,3,13,13,3,3,6,13,13,13,13,4,13,3,13,3,12,12,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,12,12,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,12,12,12,12,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,12,12,12,12,12,11,11,11,11,11,11,11,11,11,12,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,12,12],"n":["Bracket","CodeGen","Comma","Dot","Driver","Eof","Error","ErrorKind","Float","IRRepresentableExpression","IRRepresentableNode","Identifier","Integer","Interpreter","Keyword","Node","NodeId","Operator","ParseResult","Parser","Result","Semicolon","To64LLVMWord","Token","TokenKind","Tokenizer","Unknown","add_unit","as_ref","borrow","borrow","borrow","borrow","borrow","borrow","borrow","borrow","borrow","borrow","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_span","boxed_factory","can_proceed","clear_named_values","clone","clone","clone","clone","clone","clone","clone_into","clone_into","clone_into","clone_into","clone_into","clone_into","copy_float","copy_int","current_token","default","default","default","default","denotes_end_of_expression","description","deserialize","deserialize","driver","end","eq","eq","eq","errorkind","factory","fail_on_error","float_to_int","fmt","fmt","fmt","fmt","fmt","fmt","fmt","fmt","fmt","from","from","from","from","from","from","from","from","from","from","from_err","from_i128","from_i16","from_i32","from_i64","from_i8","from_u128","from_u16","from_u32","from_u64","from_u8","function_name","function_path","get_bool_type","get_context","get_float_type","get_id","get_inner","get_int_type","get_last_error","get_num_type","get_prompt","get_value","handle_expression","handle_extern_function","handle_function_definition","hash_map","impl_display","inner","int_to_float","interactive","into","into","into","into","into","into","into","into","into","into","into_iter","is_done","is_done","is_empty","is_eof","is_interactive","is_terminating","is_terminating","istream","last_error","last_unit","main_loop","main_loop","make_bool","make_f32","make_f64","make_i128","make_i16","make_i32","make_i64","make_i8","make_ir_representable_expression","make_num_from_f64","make_num_from_float","make_num_from_i128","make_num_from_int","make_u128","make_u16","make_u32","make_u64","make_u8","ne","ne","new","new","new","new","new","new","new","new_eof","next","next_token","next_token","node_clone","node_id_of_val","nodes","numeric","parse_binary_operator_rhs_expression","parse_comma_expression_list","parse_expression","parse_extern_function","parse_float_expression","parse_function","parse_function_call_expression","parse_function_prototype","parse_integer_expression","parse_once","parse_one","parse_primary_expression","parse_round_bracket_expression","parse_top_level_expression","parse_variable_expression","parser","peek_current_token","proceed_even_if_error","proceed_even_if_error","prompt","relinquish_istream","replace_used_token","represent_expression","represent_node","resolve","serialize","serialize","set_value","source","source","span","start","take_last_error","to_iter","to_owned","to_owned","to_owned","to_owned","to_owned","to_owned","to_string","to_string","to_string","to_string","to_tuple_mut","to_tuple_ref","token_kind","tokenizer","try_from","try_from","try_from","try_from","try_from","try_from","try_from","try_from","try_from","try_from","try_into","try_into","try_into","try_into","try_into","try_into","try_into","try_into","try_into","try_into","type_id","type_id","type_id","type_id","type_id","type_id","type_id","type_id","type_id","type_id","untrimmed_function_path","verbosity","verbosity","BinaryOperatorNode","Divide","Equals","ExternFunctionNode","FloatNode","FloatType","FunctionCallNode","FunctionNode","FunctionPrototypeNode","GreaterThan","GreaterThanEqual","IdentifierNode","IntegerNode","IntegerType","LessThan","LessThanEqual","Minus","Multiply","Operator","Plus","UnaryOperatorNode","Unknown","VariableExpressionNode","arguments","body","borrow","borrow","borrow","borrow","borrow","borrow","borrow","borrow","borrow","borrow","borrow","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","clone","clone","clone","clone","clone","clone","clone","clone","clone","clone","clone","clone_into","clone_into","clone_into","clone_into","clone_into","clone_into","clone_into","clone_into","clone_into","clone_into","clone_into","count_parameters","deserialize","eq","eq","eq","eq","eq","eq","eq","expr_node_clone","expr_node_clone","expr_node_clone","expr_node_clone","expr_node_clone","expr_node_clone","first","first","fmt","fmt","fmt","fmt","fmt","fmt","fmt","fmt","fmt","fmt","fmt","fmt","fmt","fmt","fmt","fmt","fmt","fmt","fmt","fmt","fmt","fmt","from","from","from","from","from","from","from","from","from","from","from","from_string","from_token","from_token","get_arguments","get_body","get_first","get_first","get_identifier","get_identifier","get_identifier","get_operator","get_operator","get_parameters","get_prototype","get_prototype","get_second","get_value","get_value","get_value","identifier","identifier","identifier","identifier","into","into","into","into","into","into","into","into","into","into","into","into","ne","ne","ne","ne","ne","ne","new","new","new","new","new","new","new","new","new","new","node_clone","node_clone","node_clone","node_clone","node_clone","node_clone","node_clone","node_clone","node_clone","node_clone","node_clone","node_id_of_val","node_id_of_val","node_id_of_val","node_id_of_val","node_id_of_val","node_id_of_val","node_id_of_val","node_id_of_val","node_id_of_val","node_id_of_val","node_id_of_val","nth_parameter","operator","operator","parameters","prototype","prototype","represent_expression","represent_expression","represent_expression","represent_expression","represent_expression","represent_expression","represent_node","represent_node","represent_node","second","serialize","to_owned","to_owned","to_owned","to_owned","to_owned","to_owned","to_owned","to_owned","to_owned","to_owned","to_owned","to_string","to_string","to_string","to_string","to_string","to_string","to_string","to_string","to_string","to_string","to_string","to_string","try_from","try_from","try_from","try_from","try_from","try_from","try_from","try_from","try_from","try_from","try_from","try_into","try_into","try_into","try_into","try_into","try_into","try_into","try_into","try_into","try_into","try_into","type_id","type_id","type_id","type_id","type_id","type_id","type_id","type_id","type_id","type_id","type_id","value","value"],"q":["kaleidoscope","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","kaleidoscope::nodes","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""],"d":["The token kind representing a bracket (e.g. ‘{’, ‘}…","A structure representing an LLVM IR generator.","The token kind representing a comma separator.","The token kind representing a period, used in attribute …","The driver that brings input from a file stream to the …","The token for when the file/stream is done.","A struct representing an error. As you can see from the …","The traits every ErrorKind enum must satisfy. If your …","The token kind representing a floating point decimal …","A node that implements this trait can be converted into …","","The token kind representing an identifier.","The token kind representing an decimal integer.","A full interpreter that can parse a programme by itself.","The token kind representing a keyword.","The trait that all node types must implement.","An ID for each node type.","The token kind representing an operator (e.g. ‘+’ in …","The return type of most parser functions in <code>Parser</code>.","The parser struct that converts a Kaleidoscope program …","A special <code>std::result::Result</code> type for Kaleidoscope. …","A semicolon denotes the end of a statement/expression","An empty struct to convert integer types into 64-bit word …","A token in a Kaleidoscope file.","The type of token a token is.","The tokeniser which iterates over the characters in a …","Default value for <code>TokenKind</code>. Reserved for situations …","Add a character into the token. This method returns a …","","","","","","","","","","","","","","","","","","","","","","Borrow the span occupied by the token as a string slice.","Convert a source error wrapped in a <code>Box</code> to an error of …","","","","","","","","","","","","","","","","","","","","","","Check whether this token is allowed to occur at the end …","","","","","","","","","","Create a function which converts a source error to an …","Set the policy of this interpreter to immediately …","","","","","","","","","","","","","","","","","","","","","A new error with another error as the source.","Convert a i128 to a 64-bit word array.","Convert a i16 to a 64-bit word array.","Convert a i32 to a 64-bit word array.","Convert a i64 to a 64-bit word array.","Convert a i8 to a 64-bit word array.","Convert a u128 to a 64-bit word array.","Convert a u16 to a 64-bit word array.","Convert a u32 to a 64-bit word array.","Convert a u64 to a 64-bit word array.","Convert a u8 to a 64-bit word array.","Get the name of the function (no paths) of the current …","Get the full qualified name of the current …","","","Get the float type for this context.","Get the raw numeric ID.","","Get the integer type for this context.","Get a reference to the last error encountered during the …","Get num type.","Get the prompt used by the driver if it is in interactive …","","The handler function which deals with expressions.","The handler function which deals with external function …","The handler function which deals with function …","Create a hash map","Implement a default version of <code>std::fmt::Display</code> for a …","","","","","","","","","","","","","","","See if any more tokens are available.","Check if there are anymore tokens in the programme.","Check if the span in the token is empty or not.","Check if this token represents an EOF character.","Check whether the driver is an interactive REPL. This …","Check whether this token kind represents a sentinel value …","Check whether this token kind represents a sentinel value …","","","","Parse a full Kaleidoscope programme.","Parse all the statements in a program until an EOF or an …","","Create a f32 from this context.","Create a f64 from this context.","Create an i128 from this context.","Create an i16 from this context.","Create an i32 from this context.","Create an i64 from this context.","Create an i8 from this context.","Generate a <code>BasicValue</code> from an expression that implements …","","","","","Create a u128 from this context.","Create a u16 value from this context.","Create a u32 from this context.","Create a u64 from this context.","Create a u8 value from this context.","","","Create a new <code>NodeId</code> from a numeric ID.","A new error. You can pass in a <code>description</code> describing …","Create a new <code>Tokenizer</code>.","Generate a new token from known values.","Create a new interpreter.","Create a new parser.","Create a new driver for parsing a Kaleidoscope programme.","A new token whose <code>TokenKind</code> is <code>TokenKind::Eof</code>.","","Get the next token by reading from a file stream.","Replace the token the parser is currently reading with …","Clone this node.","Get the <code>NodeId</code> of a node. This <code>NodeId</code> classifies the type …","A module defining all the nodes in a Kaleidoscope …","","Parse a binary operator expression. This is similar to …","Parse a program that contains a list of expressions. Each …","Parse an expression.","Parse an extern function declaration.","Parse a float expression.","Parse a function definition.","Parse a call to a function. Such an expression comes in …","Parse a function prototype.","Parse an integer expression.","Parse one statement. If the interpreter can parse more …","Parse one statement.","Parse a so-called “primary” expression. You can think …","Parse an expression wrapped inside 2 round brackets.","Converts an expression into an anonymous function.","Parse a variable expression.","","Peek at the current token being stored, without marking …","Set the policy of this interpreter to continue parsing …","","","Get the <code>FileStream</code> used by the interpreter.","Replace the token the parser is currently reading with …","Create the LLVM IR for this node.","","Resolve the value of the token when the end of the …","","","","","","","","Get the last error encountered during the parsing of the …","Convert this tokenizer into an iterator.","","","","","","","","","","","Package this tokeniser with a filestream.","Package this tokeniser with a filestream.","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","See <code>function_path</code>.","Get the verbosity of the driver. The greater this number …","","An AST representing an operator with 2 expressions by its …","/","==","An AST representing a function declaration whose …","A node representing a float. The float conforms to IEEE …","The type used to represent a Kaleidoscope float. This is …","A node representing a function call. This struct stores …","A node representing a function definition.","A node representing a function prototype. This contains …","","=","A struct representing a name or path that can identify an …","A node representing an integer. This integer’s internal …","The internal representation of an integer,","<","<=","-","*","A token representing an operator.","+","An AST representing an operator which takes 1 argument.","A separate variant for inputs that is not a valid operator","An expression where it’s just one variable. This is …","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","Get the number of parameters this function should be able …","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","Convert a string representation of an operator to an …","","","Get the arguments passed to the function.","Get the body of the function.","Get the first argument in the expression.","Get the first argument in the expression.","Get the name of the function.","Get the identifier in the prototype.","Get the identifier.","Get the operator in the expression.","Get the operator in the expression.","Get the parameters in the prototype.","Get the prototype node that contains the name and …","Get the prototype in the function definition.","Get the second argument in the expression.","Get the value of the underlying float.","Get the name as a string.","Get the value of this node as the raw value.","","","","","","","","","","","","","","","","","","","","","","","Create a new instance of a <code>BinaryOperatorNode</code>.","Create a new <code>ExternFunctionNode</code>.","Create a new <code>FloatNode</code>.","Create a new instance of a <code>FunctionCallNode</code>.","Create a new <code>FunctionPrototypeNode</code> object.","Create a new <code>FunctionNode</code> object.","Create a new <code>IdentifierNode</code> object.","Create a new <code>IntegerNode</code> object.","Create a new <code>UnaryOperatorNode</code> object.","Create a new <code>VariableExpressionNode</code> object.","","","","","","","","","","","","","","","","","","","","","","","Get the identifier for the parameter at <code>index</code>.","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","Convert this operator into a string representation of …","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""],"i":[1,0,1,1,0,1,0,0,1,0,0,1,1,0,1,0,0,1,0,0,0,1,0,0,0,0,1,2,2,3,4,5,6,7,2,1,8,9,10,3,4,5,6,7,2,1,8,9,10,2,4,8,6,3,4,6,2,1,10,3,4,6,2,1,10,6,6,9,2,1,8,10,2,4,2,1,8,2,3,3,1,4,4,8,6,3,3,4,4,2,2,1,1,10,3,4,5,6,7,2,1,8,9,10,4,5,5,5,5,5,5,5,5,5,5,0,0,6,6,6,3,6,6,8,6,10,6,10,10,10,0,0,6,6,10,3,4,5,6,7,2,1,8,9,10,8,7,8,2,2,10,2,1,8,8,7,8,10,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,3,1,3,4,7,2,8,9,10,2,8,7,9,11,11,0,3,9,9,9,9,9,9,9,9,9,8,10,9,9,9,9,8,9,8,8,10,8,9,12,13,2,2,1,6,4,4,2,2,8,7,3,4,6,2,1,10,3,4,2,1,7,7,2,8,3,4,5,6,7,2,1,8,9,10,3,4,5,6,7,2,1,8,9,10,3,4,5,6,7,2,1,8,9,10,0,10,10,0,14,14,0,0,0,0,0,0,14,14,0,0,0,14,14,14,14,0,14,0,14,0,15,16,17,18,19,15,20,16,21,22,23,24,14,17,18,19,15,20,16,21,22,23,24,14,17,18,19,15,20,16,21,22,23,24,14,17,18,19,15,20,16,21,22,23,24,14,20,14,18,19,20,21,22,24,14,17,19,15,22,23,24,17,23,17,17,18,18,19,19,15,15,20,20,16,16,21,21,22,22,23,23,24,24,14,14,17,18,19,15,20,16,21,22,23,24,14,14,21,22,15,16,17,23,15,20,24,17,23,20,18,16,17,19,21,22,15,20,21,24,17,18,19,15,20,16,21,22,23,24,14,14,18,19,20,21,22,24,17,18,19,15,20,16,21,22,23,24,17,18,19,15,20,16,21,22,23,24,14,17,18,19,15,20,16,21,22,23,24,14,20,17,23,20,18,16,17,19,15,22,23,24,18,20,16,17,14,17,18,19,15,20,16,21,22,23,24,14,17,18,19,15,20,16,21,22,23,24,14,14,17,18,19,15,20,16,21,22,23,24,14,17,18,19,15,20,16,21,22,23,24,14,17,18,19,15,20,16,21,22,23,24,14,19,22],"f":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,[[["char",15],["fileindex",3]],[["result",4,["bool","error"]],["error",3,["errorkind"]],["bool",15]]],[[],["str",15]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[],["str",15]],[[]],null,[[]],[[],["nodeid",3]],[[],["error",3]],[[],["codegen",3]],[[],["token",3]],[[],["tokenkind",4]],[[],["driver",3]],[[]],[[]],[[]],[[]],[[]],[[]],[[["floatvalue",3]],["floatvalue",3]],[[["intvalue",3]],["intvalue",3]],null,[[],["token",3]],[[],["tokenkind",4]],[[],["interpreter",3]],[[],["driver",3]],[[],["bool",15]],null,[[],[["result",4,["token"]],["token",3]]],[[],[["tokenkind",4],["result",4,["tokenkind"]]]],null,null,[[["u64",15]],["bool",15]],[[["nodeid",3]],["bool",15]],[[["tokenkind",4]],["bool",15]],null,[[]],[[],["interpreter",3]],[[["floatvalue",3]],["intvalue",3]],[[["formatter",3]],[["error",3],["result",4,["error"]]]],[[["formatter",3]],[["error",3],["result",4,["error"]]]],[[["formatter",3]],[["error",3],["result",4,["error"]]]],[[["formatter",3]],[["error",3],["result",4,["error"]]]],[[["formatter",3]],[["error",3],["result",4,["error"]]]],[[["formatter",3]],[["error",3],["result",4,["error"]]]],[[["formatter",3]],[["error",3],["result",4,["error"]]]],[[["formatter",3]],[["error",3],["result",4,["error"]]]],[[["formatter",3]],[["error",3],["result",4,["error"]]]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[["box",3,["error","global"]],["global",3],["error",8]],["error",3]],[[["i128",15]]],[[["i16",15]]],[[["i32",15]]],[[["i64",15]]],[[["i8",15]]],[[["u128",15]]],[[["u16",15]]],[[["u32",15]]],[[["u64",15]]],[[["u8",15]]],null,null,[[],["inttype",3]],[[],["context",3]],[[],["floattype",3]],[[],["u64",15]],[[],[["codegeninner",3],["mutexguard",3,["codegeninner"]]]],[[],["inttype",3]],[[],[["option",4,["error"]],["error",3]]],[[],["structtype",3]],[[],["str",15]],[[["str",15]],[["option",4,["basicvalueenum"]],["basicvalueenum",4]]],[[["filestream",3],["tokenizer",3],["parser",3]],[["result",4,["option","error"]],["option",4,["box"]],["error",3,["errorkind"]]]],[[["filestream",3],["tokenizer",3],["parser",3]],[["option",4,["box"]],["result",4,["option","error"]],["error",3,["errorkind"]]]],[[["filestream",3],["tokenizer",3],["parser",3]],[["option",4,["box"]],["error",3,["errorkind"]],["result",4,["option","error"]]]],null,null,null,[[["intvalue",3]],["floatvalue",3]],null,[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[["filestream",3]],["bool",15]],[[],["bool",15]],[[],["bool",15]],[[],["bool",15]],[[],["bool",15]],[[],["bool",15]],[[],["bool",15]],null,null,null,[[],["usize",15]],[[["filestream",3],["tokenizer",3],["parser",3]],[["usize",15],["result",4,["usize","error"]],["error",3,["errorkind"]]]],[[["bool",15]],["intvalue",3]],[[["f32",15]],["floatvalue",3]],[[["f64",15]],["floatvalue",3]],[[["i128",15]],["intvalue",3]],[[["i16",15]],["intvalue",3]],[[["i32",15]],["intvalue",3]],[[["i64",15]],["intvalue",3]],[[["i8",15]],["intvalue",3]],[[["irrepresentableexpression",8]],[["error",3,["errorkind"]],["result",4,["basicvalueenum","error"]],["basicvalueenum",4]]],[[["f64",15]],["structvalue",3]],[[["floatvalue",3]],[["result",4,["structvalue","error"]],["structvalue",3],["error",3,["errorkind"]]]],[[["i128",15]],["structvalue",3]],[[["intvalue",3]],[["result",4,["structvalue","error"]],["structvalue",3],["error",3,["errorkind"]]]],[[["u128",15]],["intvalue",3]],[[["u16",15]],["intvalue",3]],[[["u32",15]],["intvalue",3]],[[["u64",15]],["intvalue",3]],[[["u8",15]],["intvalue",3]],[[["nodeid",3]],["bool",15]],[[["tokenkind",4]],["bool",15]],[[["u64",15]],["nodeid",3]],[[["box",3,["error","global"]],["option",4,["box"]],["string",3]],["error",3]],[[],["tokenizer",3]],[[["fileindex",3],["tokenkind",4],["string",3]],["token",3]],[[["filestream",3],["u32",15],["bool",15]],["interpreter",3]],[[],["parser",3]],[[["string",3],["u32",15],["bool",15]],["driver",3]],[[["fileindex",3]],["token",3]],[[],["option",4]],[[["filestream",3]],[["token",3],["error",3,["errorkind"]],["result",4,["token","error"]]]],[[["token",3]],[["result",4,["parser","error"]],["parser",3],["error",3,["errorkind"]]]],[[],[["node",8],["global",3],["box",3,["node","global"]]]],[[],["nodeid",3]],null,null,[[["binaryoperatorprecedence",4],["box",3,["exprnode","global"]],["bool",15],["usize",15],["operator",4],["lexertuplemut",3],["exprnode",8],["global",3]],[["result",4,["option","error"]],["option",4,["box"]],["error",3,["errorkind"]]]],[[["bracket",3],["lexertuplemut",3]],[["result",4,["option","error"]],["option",4,["vec"]],["error",3,["errorkind"]]]],[[["lexertuplemut",3]],[["result",4,["option","error"]],["option",4,["box"]],["error",3,["errorkind"]]]],[[["lexertuplemut",3]],[["option",4,["box"]],["result",4,["option","error"]],["error",3,["errorkind"]]]],[[["lexertuplemut",3]],[["result",4,["option","error"]],["option",4,["box"]],["error",3,["errorkind"]]]],[[["lexertuplemut",3]],[["option",4,["box"]],["error",3,["errorkind"]],["result",4,["option","error"]]]],[[["lexertuplemut",3]],[["result",4,["option","error"]],["option",4,["box"]],["error",3,["errorkind"]]]],[[["lexertuplemut",3]],[["option",4,["box"]],["error",3,["errorkind"]],["result",4,["option","error"]]]],[[["lexertuplemut",3]],[["result",4,["option","error"]],["option",4,["box"]],["error",3,["errorkind"]]]],[[["bool",15]],[["nodeenum",4],["result",4,["nodeenum","bool"]],["bool",15]]],[[["filestream",3],["tokenizer",3],["parser",3]],[["option",4,["nodeenum"]],["error",3,["errorkind"]],["result",4,["option","error"]]]],[[["lexertuplemut",3]],[["result",4,["option","error"]],["option",4,["box"]],["error",3,["errorkind"]]]],[[["lexertuplemut",3]],[["result",4,["option","error"]],["option",4,["box"]],["error",3,["errorkind"]]]],[[["lexertuplemut",3]],[["result",4,["option","error"]],["option",4,["box"]],["error",3,["errorkind"]]]],[[["lexertuplemut",3]],[["result",4,["option","error"]],["option",4,["box"]],["error",3,["errorkind"]]]],null,[[],[["token",3],["option",4,["token"]]]],[[],["interpreter",3]],null,null,[[],["filestream",3]],[[["token",3]],[["result",4,["parser","error"]],["parser",3],["error",3,["errorkind"]]]],[[["codegen",3]],[["error",3,["errorkind"]],["result",4,["basicvalueenum","error"]],["basicvalueenum",4]]],[[["codegen",3]],[["result",4,["anyvalueenum","error"]],["anyvalueenum",4],["error",3,["errorkind"]]]],[[["fileindex",3]],[["result",4,["bool","error"]],["error",3,["errorkind"]],["bool",15]]],[[],["result",4]],[[],["result",4]],[[["box",3,["basicvalue","global"]],["basicvalue",8],["global",3],["string",3]]],[[],[["option",4,["error"]],["error",8]]],null,null,null,[[],[["option",4,["error"]],["error",3,["errorkind"]]]],[[["filestream",3]],["tokeniterator",3]],[[]],[[]],[[]],[[]],[[]],[[]],[[],["string",3]],[[],["string",3]],[[],["string",3]],[[],["string",3]],[[["filestream",3]],["lexertuplemut",3]],[[["filestream",3]],["lexertupleref",3]],null,null,[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],[[],["typeid",3]],[[],["typeid",3]],[[],["typeid",3]],[[],["typeid",3]],[[],["typeid",3]],[[],["typeid",3]],[[],["typeid",3]],[[],["typeid",3]],[[],["typeid",3]],null,[[],["u32",15]],null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[],["binaryoperatornode",3]],[[],["externfunctionnode",3]],[[],["floatnode",3]],[[],["functioncallnode",3]],[[],["functionprototypenode",3]],[[],["functionnode",3]],[[],["identifiernode",3]],[[],["integernode",3]],[[],["unaryoperatornode",3]],[[],["variableexpressionnode",3]],[[],["operator",4]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[],["usize",15]],[[],[["operator",4],["result",4,["operator"]]]],[[["externfunctionnode",3]],["bool",15]],[[["floatnode",3]],["bool",15]],[[["functionprototypenode",3]],["bool",15]],[[["identifiernode",3]],["bool",15]],[[["integernode",3]],["bool",15]],[[["variableexpressionnode",3]],["bool",15]],[[["operator",4]],["bool",15]],[[],[["global",3],["box",3,["exprnode","global"]],["exprnode",8]]],[[],[["global",3],["box",3,["exprnode","global"]],["exprnode",8]]],[[],[["global",3],["box",3,["exprnode","global"]],["exprnode",8]]],[[],[["global",3],["box",3,["exprnode","global"]],["exprnode",8]]],[[],[["global",3],["box",3,["exprnode","global"]],["exprnode",8]]],[[],[["global",3],["box",3,["exprnode","global"]],["exprnode",8]]],null,null,[[["formatter",3]],[["error",3],["result",4,["error"]]]],[[["formatter",3]],[["error",3],["result",4,["error"]]]],[[["formatter",3]],[["error",3],["result",4,["error"]]]],[[["formatter",3]],[["error",3],["result",4,["error"]]]],[[["formatter",3]],[["error",3],["result",4,["error"]]]],[[["formatter",3]],[["error",3],["result",4,["error"]]]],[[["formatter",3]],[["error",3],["result",4,["error"]]]],[[["formatter",3]],[["error",3],["result",4,["error"]]]],[[["formatter",3]],[["error",3],["result",4,["error"]]]],[[["formatter",3]],[["error",3],["result",4,["error"]]]],[[["formatter",3]],[["error",3],["result",4,["error"]]]],[[["formatter",3]],[["error",3],["result",4,["error"]]]],[[["formatter",3]],[["error",3],["result",4,["error"]]]],[[["formatter",3]],[["error",3],["result",4,["error"]]]],[[["formatter",3]],[["error",3],["result",4,["error"]]]],[[["formatter",3]],[["error",3],["result",4,["error"]]]],[[["formatter",3]],[["error",3],["result",4,["error"]]]],[[["formatter",3]],[["error",3],["result",4,["error"]]]],[[["formatter",3]],[["error",3],["result",4,["error"]]]],[[["formatter",3]],[["error",3],["result",4,["error"]]]],[[["formatter",3]],[["error",3],["result",4,["error"]]]],[[["formatter",3]],[["error",3],["result",4,["error"]]]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[["str",15]],["operator",4]],[[["token",3]],[["result",4,["identifiernode","error"]],["error",3,["errorkind"]],["identifiernode",3]]],[[["token",3]],[["result",4,["integernode","error"]],["integernode",3],["error",3,["errorkind"]]]],[[]],[[],["exprnode",8]],[[],["box",3]],[[],["box",3]],[[],["identifiernode",3]],[[],["identifiernode",3]],[[],["identifiernode",3]],[[],["operator",4]],[[],["operator",4]],[[]],[[],["functionprototypenode",3]],[[],["functionprototypenode",3]],[[],["box",3]],[[],["f64",15]],[[],["str",15]],[[],["i128",15]],null,null,null,null,[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[],["binaryoperatorprecedence",4]],[[["externfunctionnode",3]],["bool",15]],[[["floatnode",3]],["bool",15]],[[["functionprototypenode",3]],["bool",15]],[[["identifiernode",3]],["bool",15]],[[["integernode",3]],["bool",15]],[[["variableexpressionnode",3]],["bool",15]],[[["box",3,["exprnode","global"]],["operator",4],["exprnode",8],["global",3],["box",3,["operator","global"]]],["binaryoperatornode",3]],[[["functionprototypenode",3],["global",3],["box",3,["functionprototypenode","global"]]],["externfunctionnode",3]],[[["f64",15]],["floatnode",3]],[[["vec",3,["box","global"]],["identifiernode",3],["box",3,["identifiernode","global"]],["global",3],["box",3,["exprnode","global"]]],["functioncallnode",3]],[[["identifiernode",3],["vec",3,["box","global"]],["box",3,["identifiernode","global"]],["global",3]],["functionprototypenode",3]],[[["exprnode",8],["functionprototypenode",3],["box",3,["functionprototypenode","global"]],["global",3],["box",3,["exprnode","global"]]],["functionnode",3]],[[["string",3]],["identifiernode",3]],[[["i128",15]],["integernode",3]],[[["box",3,["exprnode","global"]],["operator",4],["exprnode",8],["global",3],["box",3,["operator","global"]]],["unaryoperatornode",3]],[[["box",3,["identifiernode","global"]],["global",3],["identifiernode",3]],["variableexpressionnode",3]],[[],[["node",8],["global",3],["box",3,["node","global"]]]],[[],[["node",8],["global",3],["box",3,["node","global"]]]],[[],[["node",8],["global",3],["box",3,["node","global"]]]],[[],[["node",8],["global",3],["box",3,["node","global"]]]],[[],[["node",8],["global",3],["box",3,["node","global"]]]],[[],[["node",8],["global",3],["box",3,["node","global"]]]],[[],[["node",8],["global",3],["box",3,["node","global"]]]],[[],[["node",8],["global",3],["box",3,["node","global"]]]],[[],[["node",8],["global",3],["box",3,["node","global"]]]],[[],[["node",8],["global",3],["box",3,["node","global"]]]],[[],[["node",8],["global",3],["box",3,["node","global"]]]],[[],["nodeid",3]],[[],["nodeid",3]],[[],["nodeid",3]],[[],["nodeid",3]],[[],["nodeid",3]],[[],["nodeid",3]],[[],["nodeid",3]],[[],["nodeid",3]],[[],["nodeid",3]],[[],["nodeid",3]],[[],["nodeid",3]],[[["usize",15]],[["identifiernode",3],["option",4,["identifiernode"]]]],null,null,null,null,null,[[["codegen",3]],[["error",3,["errorkind"]],["result",4,["basicvalueenum","error"]],["basicvalueenum",4]]],[[["codegen",3]],[["error",3,["errorkind"]],["result",4,["basicvalueenum","error"]],["basicvalueenum",4]]],[[["codegen",3]],[["error",3,["errorkind"]],["result",4,["basicvalueenum","error"]],["basicvalueenum",4]]],[[["codegen",3]],[["error",3,["errorkind"]],["result",4,["basicvalueenum","error"]],["basicvalueenum",4]]],[[["codegen",3]],[["error",3,["errorkind"]],["result",4,["basicvalueenum","error"]],["basicvalueenum",4]]],[[["codegen",3]],[["error",3,["errorkind"]],["result",4,["basicvalueenum","error"]],["basicvalueenum",4]]],[[["codegen",3]],[["result",4,["anyvalueenum","error"]],["anyvalueenum",4],["error",3,["errorkind"]]]],[[["codegen",3]],[["result",4,["anyvalueenum","error"]],["anyvalueenum",4],["error",3,["errorkind"]]]],[[["codegen",3]],[["result",4,["anyvalueenum","error"]],["anyvalueenum",4],["error",3,["errorkind"]]]],null,[[],["result",4]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[],["string",3]],[[],["string",3]],[[],["string",3]],[[],["string",3]],[[],["string",3]],[[],["string",3]],[[],["string",3]],[[],["string",3]],[[],["string",3]],[[],["string",3]],[[],["string",3]],[[],["str",15]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],[[],["typeid",3]],[[],["typeid",3]],[[],["typeid",3]],[[],["typeid",3]],[[],["typeid",3]],[[],["typeid",3]],[[],["typeid",3]],[[],["typeid",3]],[[],["typeid",3]],[[],["typeid",3]],null,null],"p":[[4,"TokenKind"],[3,"Token"],[3,"NodeId"],[3,"Error"],[3,"To64LLVMWord"],[3,"CodeGen"],[3,"Tokenizer"],[3,"Interpreter"],[3,"Parser"],[3,"Driver"],[8,"Node"],[8,"IRRepresentableExpression"],[8,"IRRepresentableNode"],[4,"Operator"],[3,"FunctionCallNode"],[3,"FunctionNode"],[3,"BinaryOperatorNode"],[3,"ExternFunctionNode"],[3,"FloatNode"],[3,"FunctionPrototypeNode"],[3,"IdentifierNode"],[3,"IntegerNode"],[3,"UnaryOperatorNode"],[3,"VariableExpressionNode"]]},\
"kaleidoscope_ast":{"doc":"Member which defines structs which represent AST nodes.","t":[3,0,0,0,0,12,0,6,4,13,6,13,13,11,11,11,11,11,11,11,11,11,11,11,11,11,11,13,8,13,8,8,4,8,11,11,11,11,10,11,11,10,11,11,11,11,10,11,10,5,5,5,5,5,5,11,11,11,11,5,5,6,3,11,11,11,11,11,11,11,11,11,11,11,11,11,12,11,11,11,11,11,3,13,13,3,3,6,3,3,3,13,13,3,3,6,13,13,13,13,4,13,3,13,3,12,0,12,11,11,11,11,11,11,0,12,12,0,11,11,11,11,0,0,0,0,12,12,12,12,0,11,11,11,0,12,12,12,12,12,12,11,11,11,11,11,11,11,0,12,12,0,3,11,11,11,11,11,12,11,11,11,11,11,11,11,11,11,11,12,11,12,11,11,11,11,11,3,11,11,11,11,11,11,11,11,11,11,11,11,11,11,12,11,11,11,11,11,11,3,6,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,12,3,12,11,11,11,11,11,11,11,11,11,11,12,11,11,11,11,11,11,11,11,11,11,3,11,11,11,11,11,11,11,11,11,11,11,12,11,11,11,11,11,11,12,11,11,11,11,11,11,3,12,11,11,11,11,11,11,11,11,11,11,11,11,11,12,11,11,11,11,11,11,3,11,11,11,11,11,11,11,11,11,11,12,11,11,11,11,11,11,11,11,11,11,3,6,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,12,13,13,13,13,13,13,13,13,4,13,13,3,11,11,11,11,11,12,11,11,11,11,11,11,11,11,11,12,11,11,11,11,11,11,3,11,11,11,11,11,11,11,11,11,11,12,11,11,11,11,11,11,11,11,11,11,11,3,12],"n":["NodeId","error","node","nodeid","nodes","numeric","prelude","Error","ErrorKind","Other","Result","TypeCasting","WrongTokenKind","borrow","borrow_mut","clone","clone_into","eq","fmt","fmt","from","into","to_owned","to_string","try_from","try_into","type_id","AnyNode","ExprNode","ExprNode","FromToken","Node","NodeEnum","NodeType","borrow","borrow_mut","clone","clone_into","expr_node_clone","fmt","from","from_token","into","into_any_node","is_any_node","is_expr_node","node_clone","node_id","node_id_of_val","reify_expr_node","reify_expr_node_mut","reify_expr_node_ref","reify_node","reify_node_mut","reify_node_ref","to_owned","try_from","try_into","type_id","typeid_to_u64","upcast_expr_node","IdInner","NodeId","borrow","borrow_mut","clone","clone_into","eq","eq","fmt","fmt","from","get_id","into","ne","new","numeric","to_owned","to_string","try_from","try_into","type_id","BinaryOperatorNode","Divide","Equals","ExternFunctionNode","FloatNode","FloatType","FunctionCallNode","FunctionNode","FunctionPrototypeNode","GreaterThan","GreaterThanEqual","IdentifierNode","IntegerNode","IntegerType","LessThan","LessThanEqual","Minus","Multiply","Operator","Plus","UnaryOperatorNode","Unknown","VariableExpressionNode","arguments","binaryop","body","borrow","borrow_mut","clone","clone_into","deserialize","eq","externfunc","first","first","float","fmt","fmt","from","from_string","funccall","funcprot","function","identifier","identifier","identifier","identifier","identifier","integer","into","node_clone","node_id_of_val","operator","operator","operator","parameters","prototype","prototype","second","serialize","to_owned","to_string","to_string","try_from","try_into","type_id","unaryop","value","value","varexpr","BinaryOperatorNode","borrow","borrow_mut","clone","clone_into","expr_node_clone","first","fmt","fmt","from","get_first","get_operator","get_second","into","new","node_clone","node_id_of_val","operator","represent_expression","second","to_owned","to_string","try_from","try_into","type_id","ExternFunctionNode","borrow","borrow_mut","clone","clone_into","eq","fmt","fmt","from","get_prototype","into","ne","new","node_clone","node_id_of_val","prototype","represent_node","to_owned","to_string","try_from","try_into","type_id","FloatNode","FloatType","borrow","borrow_mut","clone","clone_into","eq","expr_node_clone","fmt","fmt","from","get_value","into","ne","new","node_clone","node_id_of_val","represent_expression","to_owned","to_string","try_from","try_into","type_id","value","FunctionCallNode","arguments","borrow","borrow_mut","clone","clone_into","expr_node_clone","fmt","fmt","from","get_arguments","get_identifier","identifier","into","new","node_clone","node_id_of_val","represent_expression","to_owned","to_string","try_from","try_into","type_id","FunctionPrototypeNode","borrow","borrow_mut","clone","clone_into","count_parameters","eq","fmt","fmt","from","get_identifier","get_parameters","identifier","into","ne","new","node_clone","node_id_of_val","nth_parameter","parameters","represent_node","to_owned","to_string","try_from","try_into","type_id","FunctionNode","body","borrow","borrow_mut","clone","clone_into","fmt","fmt","from","get_body","get_prototype","into","new","node_clone","node_id_of_val","prototype","represent_node","to_owned","to_string","try_from","try_into","type_id","IdentifierNode","borrow","borrow_mut","clone","clone_into","eq","fmt","fmt","from","from_token","get_value","identifier","into","ne","new","node_clone","node_id_of_val","to_owned","to_string","try_from","try_into","type_id","IntegerNode","IntegerType","borrow","borrow_mut","clone","clone_into","eq","expr_node_clone","fmt","fmt","from","from_token","get_value","into","ne","new","node_clone","node_id_of_val","represent_expression","to_owned","to_string","try_from","try_into","type_id","value","Divide","Equals","GreaterThan","GreaterThanEqual","LessThan","LessThanEqual","Minus","Multiply","Operator","Plus","Unknown","UnaryOperatorNode","borrow","borrow_mut","clone","clone_into","expr_node_clone","first","fmt","fmt","from","get_first","get_operator","into","new","node_clone","node_id_of_val","operator","represent_expression","to_owned","to_string","try_from","try_into","type_id","VariableExpressionNode","borrow","borrow_mut","clone","clone_into","eq","expr_node_clone","fmt","fmt","from","get_identifier","identifier","into","ne","new","node_clone","node_id_of_val","represent_expression","to_owned","to_string","try_from","try_into","type_id","NodeId","numeric"],"q":["kaleidoscope_ast","","","","","","","kaleidoscope_ast::error","","","","","","","","","","","","","","","","","","","","kaleidoscope_ast::node","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","kaleidoscope_ast::nodeid","","","","","","","","","","","","","","","","","","","","","kaleidoscope_ast::nodes","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","kaleidoscope_ast::nodes::binaryop","","","","","","","","","","","","","","","","","","","","","","","","","kaleidoscope_ast::nodes::externfunc","","","","","","","","","","","","","","","","","","","","","","kaleidoscope_ast::nodes::float","","","","","","","","","","","","","","","","","","","","","","","","kaleidoscope_ast::nodes::funccall","","","","","","","","","","","","","","","","","","","","","","","kaleidoscope_ast::nodes::funcprot","","","","","","","","","","","","","","","","","","","","","","","","","","kaleidoscope_ast::nodes::function","","","","","","","","","","","","","","","","","","","","","","kaleidoscope_ast::nodes::identifier","","","","","","","","","","","","","","","","","","","","","","kaleidoscope_ast::nodes::integer","","","","","","","","","","","","","","","","","","","","","","","","","kaleidoscope_ast::nodes::operator","","","","","","","","","","","kaleidoscope_ast::nodes::unaryop","","","","","","","","","","","","","","","","","","","","","","","kaleidoscope_ast::nodes::varexpr","","","","","","","","","","","","","","","","","","","","","","","kaleidoscope_ast::prelude",""],"d":["An ID for each node type.","Error types used in <code>kaleidoscope_ast</code>.","Module which defines traits AST nodes can implement as …","A struct classifying each node type with an integer ID. …","A module defining all the nodes in a Kaleidoscope …","","Module which re-exports some of the most commonly used …","Special error type for this <code>crate</code>.","The kind of error encountered.","","Custom result type for the error type defined here.","","","","","","","","","","","","","","","","","","A node representing an expression.","","A node that implements this trait can convert one token …","The trait that all node types must implement.","A common enumerator for passing nodes as a return value …","Types which act as nodes in an AST of a Kaleidoscope …","","","","","","","","Create an instance of the node in question from one token.","","Convert the node enum into <code>Box<dyn Node></code>. This function …","Check if the node is of type <code>dyn</code> <code>Node</code>.","Check if the node is of type <code>dyn</code> <code>ExprNode</code>.","Clone this node.","Get the <code>NodeId</code> of a node type.","Get the <code>NodeId</code> of a node. This <code>NodeId</code> classifies the type …","Convert an expression node as a trait object and convert …","Convert a boxed <code>ExprNode</code> to a mutable reference to a node …","Convert a boxed <code>ExprNode</code> to an immutable reference to a …","Convert a node as a trait object and convert it into a …","Convert a boxed <code>Node</code> to a mutable reference to a node …","Convert a boxed <code>Node</code> to an immutable reference to a node …","","","","","Convert the <code>TypeId</code> of a type into its underlying <code>u64</code> …","Convert an <code>ExprNode</code> to <code>Node</code>.","The underlying type for <code>NodeId</code>","An ID for each node type.","","","","","","","","","","Get the raw numeric ID.","","","Create a new <code>NodeId</code> from a numeric ID.","","","","","","","An AST representing an operator with 2 expressions by its …","/","==","An AST representing a function declaration whose …","A node representing a float. The float conforms to IEEE …","The type used to represent a Kaleidoscope float. This is …","A node representing a function call. This struct stores …","A node representing a function definition.","A node representing a function prototype. This contains …","","=","A struct representing a name or path that can identify an …","A node representing an integer. This integer’s internal …","The internal representation of an integer,","<","<=","-","*","A token representing an operator.","+","An AST representing an operator which takes 1 argument.","A separate variant for inputs that is not a valid operator","An expression where it’s just one variable. This is …","","A module defining a <code>BinaryOperatorNode</code>.","","","","","","","","A module defining an <code>ExternFunctionNode</code>.","","","A module defining a <code>FloatNode</code>.","","","","Convert a string representation of an operator to an …","A module that defines a node representing a function call.","A module for <code>FunctionPrototypeNode</code>.","A module defining a <code>FunctionNode</code>.","A module defining a node that represents an identifier.","","","","","A module defining a node representing an integer.","","","","A module defining an operator node.","","","","","","","","","Convert this operator into a string representation of …","","","","","A module defining a <code>UnaryOperatorNode</code>.","","","A module defining a <code>VariableExpressionNode</code>.","An AST representing an operator with 2 expressions by its …","","","","","","","","","","Get the first argument in the expression.","Get the operator in the expression.","Get the second argument in the expression.","","Create a new instance of a <code>BinaryOperatorNode</code>.","","","","","","","","","","","An AST representing a function declaration whose …","","","","","","","","","Get the prototype node that contains the name and …","","","Create a new <code>ExternFunctionNode</code>.","","","","","","","","","","A node representing a float. The float conforms to IEEE …","The type used to represent a Kaleidoscope float. This is …","","","","","","","","","","Get the value of the underlying float.","","","Create a new <code>FloatNode</code>.","","","","","","","","","","A node representing a function call. This struct stores …","","","","","","","","","","Get the arguments passed to the function.","Get the name of the function.","","","Create a new instance of a <code>FunctionCallNode</code>.","","","","","","","","","A node representing a function prototype. This contains …","","","","","Get the number of parameters this function should be able …","","","","","Get the identifier in the prototype.","Get the parameters in the prototype.","","","","Create a new <code>FunctionPrototypeNode</code> object.","","","Get the identifier for the parameter at <code>index</code>.","","","","","","","","A node representing a function definition.","","","","","","","","","Get the body of the function.","Get the prototype in the function definition.","","Create a new <code>FunctionNode</code> object.","","","","","","","","","","A struct representing a name or path that can identify an …","","","","","","","","","","Get the name as a string.","","","","Create a new <code>IdentifierNode</code> object.","","","","","","","","A node representing an integer. This integer’s internal …","The internal representation of an integer,","","","","","","","","","","","Get the value of this node as the raw value.","","","Create a new <code>IntegerNode</code> object.","","","","","","","","","","/","==","","=","<","<=","-","*","A token representing an operator.","+","A separate variant for inputs that is not a valid operator","An AST representing an operator which takes 1 argument.","","","","","","","","","","Get the first argument in the expression.","Get the operator in the expression.","","Create a new <code>UnaryOperatorNode</code> object.","","","","","","","","","","An expression where it’s just one variable. This is …","","","","","","","","","","Get the identifier.","","","","Create a new <code>VariableExpressionNode</code> object.","","","","","","","","","An ID for each node type.",""],"i":[0,0,0,0,0,1,0,0,0,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,0,3,0,0,0,0,3,3,3,3,4,3,3,5,3,3,3,3,6,7,6,0,0,0,0,0,0,3,3,3,3,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,8,8,0,0,0,0,0,0,8,8,0,0,0,8,8,8,8,0,8,0,8,0,9,0,10,8,8,8,8,8,8,0,11,12,0,8,8,8,8,0,0,0,0,9,13,14,15,0,8,8,8,0,11,12,13,16,10,11,8,8,8,8,8,8,8,0,17,18,0,0,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,0,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,0,0,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,0,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,0,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,0,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,0,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,0,0,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,8,8,8,8,8,8,8,8,0,8,8,0,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,0,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,0,1],"f":[null,null,null,null,null,null,null,null,null,null,null,null,null,[[]],[[]],[[],["errorkind",4]],[[]],[[["errorkind",4]],["bool",15]],[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[]],[[]],[[]],[[],["string",3]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],null,null,null,null,null,null,null,[[]],[[]],[[]],[[]],[[],[["exprnode",8],["box",3,["exprnode"]]]],[[["formatter",3]],["result",6]],[[]],[[["token",3]],["result",6]],[[]],[[],[["box",3,["node"]],["node",8]]],[[],["bool",15]],[[],["bool",15]],[[],[["box",3,["node"]],["node",8]]],[[],["nodeid",3]],[[],["nodeid",3]],[[["exprnode",8],["box",3,["exprnode"]]],[["option",4,["box"]],["box",3]]],[[["box",3]],["option",4]],[[["box",3]],["option",4]],[[["box",3,["node"]],["node",8]],[["option",4,["box"]],["box",3]]],[[["box",3]],["option",4]],[[["box",3]],["option",4]],[[]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],[[],["u64",15]],[[["exprnode",8],["box",3,["exprnode"]]],[["box",3,["node"]],["node",8]]],null,null,[[]],[[]],[[],["nodeid",3]],[[]],[[["u64",15]],["bool",15]],[[["nodeid",3]],["bool",15]],[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[]],[[],["u64",15]],[[]],[[["nodeid",3]],["bool",15]],[[["u64",15]]],null,[[]],[[],["string",3]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,[[]],[[]],[[],["operator",4]],[[]],[[],[["result",4,["operator"]],["operator",4]]],[[["operator",4]],["bool",15]],null,null,null,null,[[["formatter",3]],[["error",3],["result",4,["error"]]]],[[["formatter",3]],[["error",3],["result",4,["error"]]]],[[]],[[["str",15]],["operator",4]],null,null,null,null,null,null,null,null,null,[[]],[[],[["box",3,["node"]],["node",8]]],[[],["nodeid",3]],null,null,null,null,null,null,null,[[],["result",4]],[[]],[[],["str",15]],[[],["string",3]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],null,null,null,null,null,[[]],[[]],[[]],[[]],[[],[["exprnode",8],["box",3,["exprnode"]]]],null,[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[]],[[],["box",3]],[[],["operator",4]],[[],["box",3]],[[]],[[["operator",4],["box",3,["operator"]],["exprnode",8],["box",3,["exprnode"]]]],[[],[["box",3,["node"]],["node",8]]],[[],["nodeid",3]],null,[[["codegen",3]],[["basicvalueenum",4],["result",6,["basicvalueenum"]]]],null,[[]],[[],["string",3]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],null,[[]],[[]],[[]],[[]],[[["externfunctionnode",3]],["bool",15]],[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[]],[[],["functionprototypenode",3]],[[]],[[["externfunctionnode",3]],["bool",15]],[[["box",3,["functionprototypenode"]],["functionprototypenode",3]],["externfunctionnode",3]],[[],[["box",3,["node"]],["node",8]]],[[],["nodeid",3]],null,[[["codegen",3]],[["anyvalueenum",4],["result",6,["anyvalueenum"]]]],[[]],[[],["string",3]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],null,null,[[]],[[]],[[],["floatnode",3]],[[]],[[["floatnode",3]],["bool",15]],[[],[["exprnode",8],["box",3,["exprnode"]]]],[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[]],[[],["floattype",6]],[[]],[[["floatnode",3]],["bool",15]],[[["floattype",6]]],[[],[["box",3,["node"]],["node",8]]],[[],["nodeid",3]],[[["codegen",3]],[["basicvalueenum",4],["codegenresult",6,["basicvalueenum"]]]],[[]],[[],["string",3]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],null,null,null,[[]],[[]],[[]],[[]],[[],[["exprnode",8],["box",3,["exprnode"]]]],[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[]],[[]],[[],["identifiernode",3]],null,[[]],[[["box",3,["identifiernode"]],["identifiernode",3],["vec",3,["box"]],["box",3,["exprnode"]]]],[[],[["box",3,["node"]],["node",8]]],[[],["nodeid",3]],[[["codegen",3]],[["basicvalueenum",4],["result",6,["basicvalueenum"]]]],[[]],[[],["string",3]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],null,[[]],[[]],[[],["functionprototypenode",3]],[[]],[[],["usize",15]],[[["functionprototypenode",3]],["bool",15]],[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[]],[[],["identifiernode",3]],[[]],null,[[]],[[["functionprototypenode",3]],["bool",15]],[[["box",3,["identifiernode"]],["vec",3,["box"]],["identifiernode",3]]],[[],[["box",3,["node"]],["node",8]]],[[],["nodeid",3]],[[["usize",15]],[["option",4,["identifiernode"]],["identifiernode",3]]],null,[[["codegen",3]],[["anyvalueenum",4],["result",6,["anyvalueenum"]]]],[[]],[[],["string",3]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],null,null,[[]],[[]],[[]],[[]],[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[]],[[],["exprnode",8]],[[],["functionprototypenode",3]],[[]],[[["box",3,["exprnode"]],["box",3,["functionprototypenode"]],["exprnode",8],["functionprototypenode",3]]],[[],[["box",3,["node"]],["node",8]]],[[],["nodeid",3]],null,[[["codegen",3]],[["anyvalueenum",4],["result",6,["anyvalueenum"]]]],[[]],[[],["string",3]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],null,[[]],[[]],[[],["identifiernode",3]],[[]],[[["identifiernode",3]],["bool",15]],[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[]],[[["token",3]],["result",6]],[[],["str",15]],null,[[]],[[["identifiernode",3]],["bool",15]],[[["string",3]]],[[],[["box",3,["node"]],["node",8]]],[[],["nodeid",3]],[[]],[[],["string",3]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],null,null,[[]],[[]],[[],["integernode",3]],[[]],[[["integernode",3]],["bool",15]],[[],[["exprnode",8],["box",3,["exprnode"]]]],[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[]],[[["token",3]],["result",6]],[[],["integertype",6]],[[]],[[["integernode",3]],["bool",15]],[[["integertype",6]]],[[],[["box",3,["node"]],["node",8]]],[[],["nodeid",3]],[[["codegen",3]],[["basicvalueenum",4],["codegenresult",6,["basicvalueenum"]]]],[[]],[[],["string",3]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],null,null,null,null,null,null,null,null,null,null,null,null,null,[[]],[[]],[[]],[[]],[[],[["exprnode",8],["box",3,["exprnode"]]]],null,[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[]],[[],["box",3]],[[],["operator",4]],[[]],[[["operator",4],["box",3,["operator"]],["exprnode",8],["box",3,["exprnode"]]]],[[],[["box",3,["node"]],["node",8]]],[[],["nodeid",3]],null,[[["codegen",3]],[["basicvalueenum",4],["result",6,["basicvalueenum"]]]],[[]],[[],["string",3]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],null,[[]],[[]],[[],["variableexpressionnode",3]],[[]],[[["variableexpressionnode",3]],["bool",15]],[[],[["exprnode",8],["box",3,["exprnode"]]]],[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[]],[[],["identifiernode",3]],null,[[]],[[["variableexpressionnode",3]],["bool",15]],[[["box",3,["identifiernode"]],["identifiernode",3]]],[[],[["box",3,["node"]],["node",8]]],[[],["nodeid",3]],[[["codegen",3]],[["basicvalueenum",4],["result",6,["basicvalueenum"]]]],[[]],[[],["string",3]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],null,null],"p":[[3,"NodeId"],[4,"ErrorKind"],[4,"NodeEnum"],[8,"ExprNode"],[8,"FromToken"],[8,"Node"],[8,"NodeType"],[4,"Operator"],[3,"FunctionCallNode"],[3,"FunctionNode"],[3,"BinaryOperatorNode"],[3,"UnaryOperatorNode"],[3,"FunctionPrototypeNode"],[3,"IdentifierNode"],[3,"VariableExpressionNode"],[3,"ExternFunctionNode"],[3,"FloatNode"],[3,"IntegerNode"]]},\
"kaleidoscope_codegen":{"doc":"A crate for building LLVM IR using the Inkwell LLVM …","t":[0,0,0,0,0,0,0,5,5,5,17,3,5,5,11,11,11,5,5,11,5,5,5,5,5,5,5,5,5,5,12,11,5,5,11,11,11,11,11,11,11,11,11,11,5,11,11,5,11,5,11,5,5,11,11,11,5,5,11,11,11,11,11,11,12,3,3,6,11,11,11,11,12,11,11,11,12,11,11,5,12,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,12,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,12,12,11,11,11,11,11,11,11,11,11,11,13,13,6,4,13,13,6,13,13,13,13,11,11,11,11,11,11,11,11,11,11,11,11,11,11,3,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,8,8,10,10],"n":["builtins","codegen","error","int","traits","global","number","func_create_error","get_binop_types","make_num_add","NUM_TYPE_NAME","NumValue","add_floats","add_ints","borrow","borrow_mut","cast_to_same_type_as","check_float_formats","check_int_types","cmp","cmp_eq_floats","cmp_eq_ints","cmp_ge_floats","cmp_ge_ints","cmp_gt_floats","cmp_gt_ints","cmp_le_floats","cmp_le_ints","cmp_lt_floats","cmp_lt_ints","code_gen","destructure","div_floats","div_ints","eq","fmt","from","get_int_switch","get_raw_float_value","get_raw_int_value","into","into","is_float","is_int","make_bit_width_error","make_f64","make_false","make_float_format_error","make_i128","make_number_type","make_true","mul_floats","mul_ints","new","partial_cmp","simplify_to_basic_value","sub_floats","sub_ints","to_float","to_int","to_string","try_from","try_into","type_id","value","CodeGen","CodeGenInner","NamedValues","borrow","borrow","borrow_mut","borrow_mut","builder","clear_named_values","clone","clone_into","context","copy_float","copy_int","create_code_gen","engine","float_to_int","from","from","get_bool_type","get_builder","get_context","get_context","get_engine","get_float_type","get_inner","get_int_type","get_module","get_mut_named_values","get_named_values","get_num_type","get_value","init","inner","int_to_float","into","into","make_bool","make_f32","make_f64","make_i128","make_i16","make_i32","make_i64","make_i8","make_ir_representable_expression","make_num_from_f64","make_num_from_float","make_num_from_i128","make_num_from_int","make_u128","make_u16","make_u32","make_u64","make_u8","module","named_values","new","new","set_value","to_owned","try_from","try_from","try_into","try_into","type_id","type_id","BitWidthError","CouldNotMakeFunctionError","Error","ErrorKind","NotBasicValueError","Other","Result","TypeError","UndefinedNameError","UnknownOperationError","ValueError","borrow","borrow_mut","clone","clone_into","eq","fmt","fmt","from","into","to_owned","to_string","try_from","try_into","type_id","To64LLVMWord","borrow","borrow_mut","from","from_i128","from_i16","from_i32","from_i64","from_i8","from_u128","from_u16","from_u32","from_u64","from_u8","into","try_from","try_into","type_id","IRRepresentableExpression","IRRepresentableNode","represent_expression","represent_node"],"q":["kaleidoscope_codegen","","","","","kaleidoscope_codegen::builtins","","kaleidoscope_codegen::builtins::global","","","kaleidoscope_codegen::builtins::number","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","kaleidoscope_codegen::codegen","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","kaleidoscope_codegen::error","","","","","","","","","","","","","","","","","","","","","","","","","kaleidoscope_codegen::int","","","","","","","","","","","","","","","","","","kaleidoscope_codegen::traits","","",""],"d":["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","A structure representing an LLVM IR generator.","","","","","","","","","","","","","","Create a new LLVM IR generator.","","","","","","","","","","Get the float type for this context.","","Get the integer type for this context.","","","","Get num type.","","","","","","","","Create a f32 from this context.","Create a f64 from this context.","Create an i128 from this context.","Create an i16 from this context.","Create an i32 from this context.","Create an i64 from this context.","Create an i8 from this context.","Generate a <code>BasicValue</code> from an expression that implements …","","","","","Create a u128 from this context.","Create a u16 value from this context.","Create a u32 from this context.","Create a u64 from this context.","Create a u8 value from this context.","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","An empty struct to convert integer types into 64-bit word …","","","","Convert a i128 to a 64-bit word array.","Convert a i16 to a 64-bit word array.","Convert a i32 to a 64-bit word array.","Convert a i64 to a 64-bit word array.","Convert a i8 to a 64-bit word array.","Convert a u128 to a 64-bit word array.","Convert a u16 to a 64-bit word array.","Convert a u32 to a 64-bit word array.","Convert a u64 to a 64-bit word array.","Convert a u8 to a 64-bit word array.","","","","","A node that implements this trait can be converted into …","","Create the LLVM IR for this node.",""],"i":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,1,1,1,1,1,1,1,1,1,1,0,1,1,0,1,0,1,0,0,1,1,1,0,0,1,1,1,1,1,1,1,0,0,0,2,3,2,3,2,3,3,3,2,3,3,0,2,3,2,3,3,2,2,3,2,3,3,3,2,2,2,3,3,3,3,3,2,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,2,2,3,3,3,2,3,2,3,2,3,4,4,0,0,4,4,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,0,0,6,7],"f":[null,null,null,null,null,null,null,[[["str",15]]],[[["codegen",3]]],[[["codegen",3]],[["functionvalue",3],["result",6,["functionvalue"]]]],null,null,[[["floatvalue",3],["codegen",3]],[["floatvalue",3],["result",6,["floatvalue"]]]],[[["intvalue",3],["codegen",3]],[["result",6,["intvalue"]],["intvalue",3]]],[[]],[[]],[[],["result",6]],[[["floatvalue",3]],["bool",15]],[[["intvalue",3]],["bool",15]],[[],["ordering",4]],[[["floatvalue",3],["codegen",3]],[["result",6,["intvalue"]],["intvalue",3]]],[[["intvalue",3],["codegen",3]],[["result",6,["intvalue"]],["intvalue",3]]],[[["floatvalue",3],["codegen",3]],[["result",6,["intvalue"]],["intvalue",3]]],[[["intvalue",3],["codegen",3]],[["result",6,["intvalue"]],["intvalue",3]]],[[["floatvalue",3],["codegen",3]],[["result",6,["intvalue"]],["intvalue",3]]],[[["intvalue",3],["codegen",3]],[["result",6,["intvalue"]],["intvalue",3]]],[[["floatvalue",3],["codegen",3]],[["result",6,["intvalue"]],["intvalue",3]]],[[["intvalue",3],["codegen",3]],[["result",6,["intvalue"]],["intvalue",3]]],[[["floatvalue",3],["codegen",3]],[["result",6,["intvalue"]],["intvalue",3]]],[[["intvalue",3],["codegen",3]],[["result",6,["intvalue"]],["intvalue",3]]],null,[[]],[[["floatvalue",3],["codegen",3]],[["floatvalue",3],["result",6,["floatvalue"]]]],[[["intvalue",3],["codegen",3]],[["result",6,["intvalue"]],["intvalue",3]]],[[],["bool",15]],[[["formatter",3]],["result",6]],[[]],[[],["intvalue",3]],[[],["floatvalue",3]],[[],["intvalue",3]],[[]],[[],["structvalue",3]],[[],["bool",15]],[[],["bool",15]],[[["intvalue",3]],["error",6]],[[["codegen",3],["f64",15]]],[[],["intvalue",3]],[[["floatvalue",3]],["error",6]],[[["codegen",3],["i128",15]]],[[["codegen",3]],["structtype",3]],[[],["intvalue",3]],[[["floatvalue",3],["codegen",3]],[["floatvalue",3],["result",6,["floatvalue"]]]],[[["intvalue",3],["codegen",3]],[["result",6,["intvalue"]],["intvalue",3]]],[[["codegen",3],["structvalue",3]],["result",6]],[[],[["option",4,["ordering"]],["ordering",4]]],[[],[["box",3,["basicvalue"]],["basicvalue",8]]],[[["floatvalue",3],["codegen",3]],[["floatvalue",3],["result",6,["floatvalue"]]]],[[["intvalue",3],["codegen",3]],[["result",6,["intvalue"]],["intvalue",3]]],[[],["result",6]],[[],["result",6]],[[],["string",3]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],null,null,null,null,[[]],[[]],[[]],[[]],null,[[]],[[],["codegen",3]],[[]],null,[[["floatvalue",3]],["floatvalue",3]],[[["intvalue",3]],["intvalue",3]],[[["context",3],["executionengine",3],["module",3]],["codegen",3]],null,[[["floatvalue",3]],["intvalue",3]],[[]],[[]],[[],["inttype",3]],[[],["builder",3]],[[],["context",3]],[[],["context",3]],[[],["executionengine",3]],[[],["floattype",3]],[[],[["codegeninner",3],["mutexguard",3,["codegeninner"]]]],[[],["inttype",3]],[[],["module",3]],[[],["namedvalues",6]],[[],["namedvalues",6]],[[],["structtype",3]],[[["str",15]],[["basicvalueenum",4],["option",4,["basicvalueenum"]]]],[[]],null,[[["intvalue",3]],["floatvalue",3]],[[]],[[]],[[["bool",15]],["intvalue",3]],[[["f32",15]],["floatvalue",3]],[[["f64",15]],["floatvalue",3]],[[["i128",15]],["intvalue",3]],[[["i16",15]],["intvalue",3]],[[["i32",15]],["intvalue",3]],[[["i64",15]],["intvalue",3]],[[["i8",15]],["intvalue",3]],[[["irrepresentableexpression",8]],[["result",6,["basicvalueenum"]],["basicvalueenum",4]]],[[["f64",15]],["structvalue",3]],[[["floatvalue",3]],[["result",6,["structvalue"]],["structvalue",3]]],[[["i128",15]],["structvalue",3]],[[["intvalue",3]],[["result",6,["structvalue"]],["structvalue",3]]],[[["u128",15]],["intvalue",3]],[[["u16",15]],["intvalue",3]],[[["u32",15]],["intvalue",3]],[[["u64",15]],["intvalue",3]],[[["u8",15]],["intvalue",3]],null,null,[[["context",3],["executionengine",3],["module",3]]],[[["context",3],["executionengine",3],["module",3]]],[[["string",3],["box",3,["basicvalue"]],["basicvalue",8]]],[[]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],[[],["typeid",3]],null,null,null,null,null,null,null,null,null,null,null,[[]],[[]],[[],["errorkind",4]],[[]],[[["errorkind",4]],["bool",15]],[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[]],[[]],[[]],[[],["string",3]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],null,[[]],[[]],[[]],[[["i128",15]]],[[["i16",15]]],[[["i32",15]]],[[["i64",15]]],[[["i8",15]]],[[["u128",15]]],[[["u16",15]]],[[["u32",15]]],[[["u64",15]]],[[["u8",15]]],[[]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],null,null,[[["codegen",3]],[["result",6,["basicvalueenum"]],["basicvalueenum",4]]],[[["codegen",3]],[["result",6,["anyvalueenum"]],["anyvalueenum",4]]]],"p":[[3,"NumValue"],[3,"CodeGenInner"],[3,"CodeGen"],[4,"ErrorKind"],[3,"To64LLVMWord"],[8,"IRRepresentableExpression"],[8,"IRRepresentableNode"]]},\
"kaleidoscope_error":{"doc":"Custom error library for Kaleidoscope.","t":[3,8,6,11,11,11,11,11,12,12,11,11,11,11,11,11,11,11,12,11,11,11,11,11],"n":["Error","ErrorKind","Result","borrow","borrow_mut","boxed_factory","clone","clone_into","description","errorkind","factory","fmt","fmt","from","from_err","into","new","source","source","to_owned","to_string","try_from","try_into","type_id"],"q":["kaleidoscope_error","","","","","","","","","","","","","","","","","","","","","","",""],"d":["A struct representing an error. As you can see from the …","The traits every ErrorKind enum must satisfy. If your …","A special <code>std::result::Result</code> type for Kaleidoscope. …","","","Convert a source error wrapped in a <code>Box</code> to an error of …","","","","","Create a function which converts a source error to an …","","","","A new error with another error as the source.","","A new error. You can pass in a <code>description</code> describing …","","","","","","",""],"i":[0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],"f":[null,null,null,[[]],[[]],[[]],[[]],[[]],null,null,[[]],[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[]],[[["box",3,["error"]],["error",8]]],[[]],[[["string",3],["box",3,["error"]],["option",4,["box"]]]],[[],[["error",8],["option",4,["error"]]]],null,[[]],[[],["string",3]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]]],"p":[[3,"Error"]]},\
"kaleidoscope_lexer":{"doc":"This library contains utilities which converts a stream …","t":[0,14,14,0,0,0,13,6,4,13,13,13,13,13,13,13,6,11,11,11,11,11,11,11,11,11,11,11,11,11,11,13,3,13,4,4,13,13,13,13,13,13,13,13,13,3,13,13,13,13,13,13,4,13,17,17,17,17,13,13,13,13,13,4,13,13,17,17,17,17,13,13,13,13,13,3,4,17,13,13,13,0,0,12,12,0,0,12,12,0,12,12,12,0,12,0,13,3,4,4,13,13,13,13,13,13,11,11,11,11,11,11,11,0,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,12,11,11,11,11,11,12,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,3,11,11,11,11,11,11,12,11,11,11,11,11,11,11,11,11,12,11,11,11,11,11,11,11,11,11,11,13,13,13,13,4,13,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,13,13,13,13,13,13,13,13,4,13,13,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,3,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,12,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,12,12,11,11,12,11,11,11,13,13,13,13,13,13,13,13,13,13,4,13,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,12,12,12,12,3,3,3,3,3,3,12,12,12,12,12,0,12,12,0,0,12,12,12,0,12,0,6,3,11,11,12,12,11,11,12,12,11,11,11,11,11,11,11,11,11,11,12,11,11,11,12,11,11,11,11,11,11,11,11,11,3,11,11,11,11,11,11,12,11,11,11,12,12,12,12,3,3,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,3,11,11,11,11,11,12,11,11,11,11,11,11,11,11,3,11,11,12,11,11,11,11,11,11,11,11,12,11,11,12,11,11,11,5,5,5,5,5,5,5,5,5,5,5,5,5,5],"n":["error","ltuplemut","ltupleref","token","tokenizer","utils","BadChar","Error","ErrorKind","ExcessiveChars","FileIOError","InvalidChar","InvalidCombo","InvalidToken","LexerFatal","Other","Result","borrow","borrow_mut","clone","clone_into","eq","fmt","fmt","from","into","to_owned","to_string","try_from","try_into","type_id","Angled","Bracket","Bracket","BracketKind","BracketSide","Comma","Curly","Def","Divide","Dot","Else","Eof","Equals","Extern","FileIndex","Float","GreaterThan","GreaterThanEqual","Identifier","If","Integer","Keyword","Keyword","LEFT_ANGLED_BRACKET","LEFT_CURLY_BRACKET","LEFT_ROUND_BRACKET","LEFT_SQUARE_BRACKET","Left","LessThan","LessThanEqual","Minus","Multiply","Operator","Operator","Plus","RIGHT_ANGLED_BRACKET","RIGHT_CURLY_BRACKET","RIGHT_ROUND_BRACKET","RIGHT_SQUARE_BRACKET","Right","Round","Semicolon","Square","Then","Token","TokenKind","UNKNOWN_BRACKET","Unknown","Unknown","Unknown","bracket","brackets","column","end","fileindex","keyword","kind","line","operator","side","span","start","token","token_kind","tokenkind","Angled","Bracket","BracketKind","BracketSide","Curly","Left","Right","Round","Square","Unknown","as_int","borrow","borrow","borrow","borrow_mut","borrow_mut","borrow_mut","brackets","cancels_out","clone","clone","clone","clone_into","clone_into","clone_into","cmp","default","deserialize","deserialize","deserialize","eq","eq","eq","eq","fmt","fmt","fmt","fmt","fmt","fmt","from","from","from","from_codes","from_int","from_int","from_string","from_string","from_string","get_repr","into","into","into","into","is_invalid","is_left","is_right","is_str","kind","ne","partial_cmp","serialize","serialize","serialize","side","str_repr","to_owned","to_owned","to_owned","to_string","to_string","to_string","try_from","try_from","try_from","try_into","try_into","try_into","type_id","type_id","type_id","LEFT_ANGLED_BRACKET","LEFT_CURLY_BRACKET","LEFT_ROUND_BRACKET","LEFT_SQUARE_BRACKET","RIGHT_ANGLED_BRACKET","RIGHT_CURLY_BRACKET","RIGHT_ROUND_BRACKET","RIGHT_SQUARE_BRACKET","UNKNOWN_BRACKET","LEFT_ANGLED_BRACKET","LEFT_CURLY_BRACKET","LEFT_ROUND_BRACKET","LEFT_SQUARE_BRACKET","RIGHT_ANGLED_BRACKET","RIGHT_CURLY_BRACKET","RIGHT_ROUND_BRACKET","RIGHT_SQUARE_BRACKET","UNKNOWN_BRACKET","FileIndex","add","add_assign","borrow","borrow_mut","clone","clone_into","column","default","deserialize","fmt","fmt","from","get_column","get_line","get_line_number","into","line","new","newline","serialize","sub","sub_assign","to_owned","to_string","try_from","try_into","type_id","Def","Else","Extern","If","Keyword","Then","borrow","borrow_mut","clone","clone_into","deserialize","eq","fmt","fmt","from","from_string","into","serialize","to_owned","to_string","to_string","try_from","try_into","type_id","Divide","Equals","GreaterThan","GreaterThanEqual","LessThan","LessThanEqual","Minus","Multiply","Operator","Plus","Unknown","borrow","borrow_mut","clone","clone_into","deserialize","eq","fmt","fmt","from","from_string","into","serialize","to_owned","to_string","to_string","try_from","try_into","type_id","Token","add_unit","add_unit_if_bracket","add_unit_if_float","add_unit_if_identifier","add_unit_if_integer","add_unit_if_operator","add_unit_when_empty","add_unit_when_not_empty","as_ref","borrow","borrow_mut","borrow_span","clone","clone_into","default","denotes_end_of_expression","deserialize","end","fmt","fmt","from","into","is_empty","is_eof","is_terminating","new","new_eof","resolve","resolve_bracket","resolve_float","resolve_identifier","resolve_operator","serialize","span","start","to_owned","to_string","token_kind","try_from","try_into","type_id","Bracket","Comma","Dot","Eof","Float","Identifier","Integer","Keyword","Operator","Semicolon","TokenKind","Unknown","borrow","borrow_mut","clone","clone_into","default","deserialize","eq","fmt","fmt","from","into","is_terminating","ne","serialize","to_owned","to_string","try_from","try_into","type_id","0","0","1","1","FileStream","LexerSerializer","LexerTupleMut","LexerTupleRef","TokenIterator","Tokenizer","buffer","cursor","eof_count","eof_reached","error","filestream","index","last_unit","lexerser","lexertuple","line","stream","token_iter","tokenizer","tokenizer","tokiter","BufferIterator","FileStream","borrow","borrow_mut","buffer","cursor","default","eof_reached","eof_reached","error","from","from","from","from_bytes","from_path","from_stdin","get_err","get_index","get_mut_index","get_unit","index","init","into","into_iter","line","new","next","next_line","next_unit","silence_err","try_from","try_from","try_into","type_id","LexerSerializer","borrow","borrow_mut","from","into","new","serialize","token_iter","try_from","try_into","type_id","0","0","1","1","LexerTupleMut","LexerTupleRef","borrow","borrow","borrow_mut","borrow_mut","clone","clone_into","from","from","into","into","to_owned","try_from","try_from","try_into","try_into","type_id","type_id","Tokenizer","borrow","borrow_mut","from","into","is_done","last_unit","new","next_token","to_iter","to_tuple_mut","to_tuple_ref","try_from","try_into","type_id","TokenIterator","borrow","borrow_mut","eof_count","eof_reached","from","into","into_iter","is_done","new","next","next_token","stream","to_tuple_mut","to_tuple_ref","tokenizer","try_from","try_into","type_id","is_alpha","is_alphanum","is_bracket","is_comma","is_comment","is_decimal_digit","is_dot","is_eol","is_fullstop","is_identifier","is_identifier_start","is_opchar","is_semicolon","is_whitespace"],"q":["kaleidoscope_lexer","","","","","","kaleidoscope_lexer::error","","","","","","","","","","","","","","","","","","","","","","","","","kaleidoscope_lexer::token","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","kaleidoscope_lexer::token::bracket","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","kaleidoscope_lexer::token::bracket::brackets","","","","","","","","","kaleidoscope_lexer::token::brackets","","","","","","","","","kaleidoscope_lexer::token::fileindex","","","","","","","","","","","","","","","","","","","","","","","","","","","","kaleidoscope_lexer::token::keyword","","","","","","","","","","","","","","","","","","","","","","","","kaleidoscope_lexer::token::operator","","","","","","","","","","","","","","","","","","","","","","","","","","","","","kaleidoscope_lexer::token::token","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","kaleidoscope_lexer::token::tokenkind","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","kaleidoscope_lexer::tokenizer","","","","","","","","","","","","","","","","","","","","","","","","","","kaleidoscope_lexer::tokenizer::filestream","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","kaleidoscope_lexer::tokenizer::lexerser","","","","","","","","","","","kaleidoscope_lexer::tokenizer::lexertuple","","","","","","","","","","","","","","","","","","","","","","","kaleidoscope_lexer::tokenizer::tokenizer","","","","","","","","","","","","","","","kaleidoscope_lexer::tokenizer::tokiter","","","","","","","","","","","","","","","","","","","kaleidoscope_lexer::utils","","","","","","","","","","","","",""],"d":["Error types used in <code>kaleidoscope_lexer</code>.","A macro that can destructure or create a new <code>LexerTupleMut</code>…","A macro that can destructure or create a new <code>LexerTupleRef</code>…","Types which represent a token in a Kaleidoscope program. …","Types that converts a file into a list of tokens.","Utility functions for recognising tokens and checking …","If a character was found at the wrong place in a token.","The error type used in this library.","The kind of error encountered in this library.","If there are too many characters in a token.","If an error was encountered when reading a stream, this …","If an unrecognised character was encountered when …","If a series of characters in the wrong order or …","If the lexer could not resolve a sequence of bytes into a …","If the lexer encounters an exception that cannot be dealt …","For miscellaneous errors too obscure to have its own …","Custom result type for the error type defined here.","","","","","","","","","","","","","","","","A struct representing a bracket. This bracket can be …","The token kind representing a bracket (e.g. ‘{’, ‘}…","The type of bracket <code>Bracket</code> represents. This merely …","The orientation or side of a bracket. This can either be …","The token kind representing a comma separator.","","<code>def</code> keyword. Define a function.","/","The token kind representing a period, used in attribute …","<code>else</code> keyword. Control flow.","The token for when the file/stream is done.","==","<code>extern</code> keyword. For foreign function interfaces.","Represents the location of a character (i.e. displayed …","The token kind representing a floating point decimal …","","=","The token kind representing an identifier.","<code>if</code> keyword. Control flow.","The token kind representing an decimal integer.","An enumerator of possible keywords that can be …","The token kind representing a keyword.","<","{","(","[","","<","<=","-","*","A token representing an operator.","The token kind representing an operator (e.g. ‘+’ in …","+",">","}",")","]","","","A semicolon denotes the end of a statement/expression","","<code>then</code> keyword. Control flow.","A token in a Kaleidoscope file.","The type of token a token is.","???","","A separate variant for inputs that is not a valid operator","Default value for <code>TokenKind</code>. Reserved for situations …","A bunch of types representing a bracket such as <code>(</code> or <code>]</code>. …","All the possible bracket types that can be represented by …","","","A representation of the location of a character in a …","A enum representing a keyword. A key reason why I chose …","","","A token representing an operator.","","","","A token in a file or stream. This is the most basic unit …","","The type of the token. Such a classification allows the …","","A struct representing a bracket. This bracket can be …","The type of bracket <code>Bracket</code> represents. This merely …","The orientation or side of a bracket. This can either be …","","","","","","","Convert a <code>BracketSide</code> to an integer. This can be used to …","","","","","","","All the possible bracket types that can be represented by …","Checks if 2 brackets are of the same type.","","","","","","","","","","","","","","","","","","","","","","","","","Create a bracket from the corresponding <code>BracketKind</code> and …","Convert an integer code to a <code>BracketKind</code>.","Convert an integer to a <code>BracketSide</code>.","Convert the string representation of a bracket to a …","Convert the string representation of a bracket to a …","Create a <code>Bracket</code> from a string of a bracket. If the …","Get the string representation of each type of bracket as …","","","","","Checks if the bracket represented by this struct is …","As the name of this method suggests, it checks whether the…","Check whether the <code>BracketSide</code> matches <code>BracketSide::Right</code>.","Check if the string representation of a bracket matches a …","","","","","","","","Return the bracket as a string representaton of itself.","","","","","","","","","","","","","","","","<","{","(","[",">","}",")","]","???","<","{","(","[",">","}",")","]","???","Represents the location of a character (i.e. displayed …","","","","","","","","","","","","","Get the column of the represented by this index.","Get the line of the represented by this object.","Get the line of the represented by this object but treat …","","","Create a new <code>FileIndex</code> object.","Get the position of a character after a newline.","","","","","","","","","<code>def</code> keyword. Define a function.","<code>else</code> keyword. Control flow.","<code>extern</code> keyword. For foreign function interfaces.","<code>if</code> keyword. Control flow.","An enumerator of possible keywords that can be …","<code>then</code> keyword. Control flow.","","","","","","","","","","Convert a string to a variant of the <code>Keyword</code> enum.","","","","Convert the keyword enum into a string representation of …","","","","","/","==","","=","<","<=","-","*","A token representing an operator.","+","A separate variant for inputs that is not a valid operator","","","","","","","","","","Convert a string representation of an operator to an …","","","","Convert this operator into a string representation of …","","","","","A token in a Kaleidoscope file.","Add a character into the token. This method returns a …","","","","","","","","","","","Borrow the span occupied by the token as a string slice.","","","","Check whether this token is allowed to occur at the end …","","","","","","","Check if the span in the token is empty or not.","Check if this token represents an EOF character.","Check whether this token kind represents a sentinel value …","Generate a new token from known values.","A new token whose <code>TokenKind</code> is <code>TokenKind::Eof</code>.","Resolve the value of the token when the end of the …","","","","","","","","","","","","","","The token kind representing a bracket (e.g. ‘{’, ‘}…","The token kind representing a comma separator.","The token kind representing a period, used in attribute …","The token for when the file/stream is done.","The token kind representing a floating point decimal …","The token kind representing an identifier.","The token kind representing an decimal integer.","The token kind representing a keyword.","The token kind representing an operator (e.g. ‘+’ in …","A semicolon denotes the end of a statement/expression","The type of token a token is.","Default value for <code>TokenKind</code>. Reserved for situations …","","","","","","","","","","","","Check whether this token kind represents a sentinel value …","","","","","","","","","","","","A file stream which returns a unicode codepoint one at a …","Serialises a <code>TokenIterator</code> into a list of tokens.","A tuple storing mutable references to a <code>FileStream</code> and a …","A tuple storing immutable references to a <code>FileStream</code> and a…","A structure that takes a <code>FileStream</code> and reads the …","The tokeniser which iterates over the characters in a …","","","","","","A special structure which iterates over the characters in …","","","A module for serialising a tokeniser. This only exists so …","Some tuples storing a <code>FileStream</code> and a <code>Tokenizer</code>.","","","","A struct that reads a file and creates tokens from them.","","A module defining a <code>TokenIterator</code> that can continually …","An iterator that outputs each line in a Kaleidoscope …","A file stream which returns a unicode codepoint one at a …","","","","","","Check if the file/stream has ended (i.e. whether the …","","","","","","Create a new <code>FileStream</code> from a slice of bytes.","Create a new <code>FileStream</code> from a path.","Create a <code>FileStream</code> from the <code>stdin</code> stream. By <code>Default</code>, …","Get the error currently being stored.","Get the index of the current character.","Get a mutable reference to the index of the current …","Get the character currently being read.","","","","","","Create a new <code>FileStream</code> from an iterator over the lines …","","Push the next line into the buffer. If successful, <code>true</code> …","Read the next character in the stream. If there are no …","Set the current error to <code>None</code> and return the old error.","","","","","Serialises a <code>TokenIterator</code> into a list of tokens.","","","","","Create a new tokeniser serialiser.","","","","","","","","","","A tuple storing mutable references to a <code>FileStream</code> and a …","A tuple storing immutable references to a <code>FileStream</code> and a…","","","","","","","","","","","","","","","","","","The tokeniser which iterates over the characters in a …","","","","","See if any more tokens are available.","","Create a new <code>Tokenizer</code>.","Get the next token by reading from a file stream.","Convert this tokenizer into an iterator.","Package this tokeniser with a filestream.","Package this tokeniser with a filestream.","","","","A structure that takes a <code>FileStream</code> and reads the …","","","","Check if an EOF character has been encountered.","","","","Check if this iterator can produce more tokens.","Create a new <code>TokenIterator</code>.","","Get the next token in from the tokeniser.","","Convert this iterator into a neatly packaged tuple for …","Convert this iterator into a neatly packaged tuple for …","","","","","True if <code>unit</code> is an ASCII alphabetical character.","True if <code>unit</code> is an ASCII alphabetical character or an …","See if <code>unit</code> is a bracket character.","See if <code>unit</code> is a comma separator.","See if <code>unit</code> is the character that denotes the start of a …","True if <code>unit</code> is within ‘0’ and ‘9’.","See if <code>unit</code> is a fullstop.","Rudimentary check to see if the end of the line has been …","True if <code>unit</code> is ‘.’","True if <code>unit</code> is a character that can potentially be used …","True if <code>unit</code> is a character that can act as the first …","True if <code>unit</code> is a character used in one of the operator …","See if <code>unit</code> is a semicolon.","True if <code>unit</code> is a whitespace character, including …"],"i":[0,0,0,0,0,0,1,0,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,0,3,0,0,3,2,4,5,3,4,3,5,4,0,3,5,5,3,4,3,0,3,0,0,0,0,6,5,5,5,5,0,3,5,0,0,0,0,6,2,3,2,4,0,0,0,2,5,3,0,0,7,8,0,0,9,7,0,9,8,8,0,8,0,2,0,0,0,2,6,6,2,2,2,6,2,6,9,2,6,9,0,9,2,6,9,2,6,9,6,6,2,6,9,2,6,9,9,2,2,6,6,9,9,2,6,9,9,2,6,2,6,9,2,2,6,6,9,9,6,6,9,9,9,6,2,6,9,9,9,2,6,9,2,6,9,2,6,9,2,6,9,2,6,9,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,4,4,4,4,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,0,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,0,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,3,3,3,3,3,3,3,3,3,3,0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,10,11,10,11,0,0,0,0,0,0,12,12,13,12,12,0,12,14,0,0,12,13,15,0,13,0,0,0,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,0,15,15,15,15,15,15,15,15,15,15,10,11,10,11,0,0,10,11,10,11,11,11,10,11,10,11,11,10,11,10,11,10,11,0,14,14,14,14,14,14,14,14,14,14,14,14,14,14,0,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,0,0,0,0,0,0,0,0,0,0,0,0,0,0],"f":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,[[]],[[]],[[],["errorkind",4]],[[]],[[["errorkind",4]],["bool",15]],[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[]],[[]],[[]],[[],["string",3]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,[[],["i32",15]],[[]],[[]],[[]],[[]],[[]],[[]],null,[[],["bool",15]],[[],["bracketkind",4]],[[],["bracketside",4]],[[],["bracket",3]],[[]],[[]],[[]],[[],["ordering",4]],[[]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[["bracketkind",4]],["bool",15]],[[["bracketside",4]],["bool",15]],[[["bracket",3]],["bool",15]],[[],["bool",15]],[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[]],[[]],[[]],[[["i32",15]]],[[["i32",15]]],[[["i32",15]],["option",4]],[[["str",15]]],[[["str",15]],["option",4]],[[["str",15]]],[[]],[[]],[[],["i32",15]],[[]],[[]],[[],["bool",15]],[[],["bool",15]],[[],["bool",15]],[[["str",15]],["bool",15]],null,[[["bracket",3]],["bool",15]],[[],[["option",4,["ordering"]],["ordering",4]]],[[],["result",4]],[[],["result",4]],[[],["result",4]],null,[[],["str",15]],[[]],[[]],[[]],[[],["string",3]],[[],["string",3]],[[],["string",3]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],[[],["typeid",3]],[[],["typeid",3]],null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,[[["usize",15]]],[[["usize",15]]],[[]],[[]],[[],["fileindex",3]],[[]],null,[[]],[[],["result",4]],[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[]],[[],["usize",15]],[[],[["usize",15],["option",4,["usize"]]]],[[],["usize",15]],[[]],null,[[["usize",15],["option",4,["usize"]]]],[[["usize",15]]],[[],["result",4]],[[["usize",15]]],[[["usize",15]]],[[]],[[],["string",3]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],null,null,null,null,null,null,[[]],[[]],[[],["keyword",4]],[[]],[[],["result",4]],[[["keyword",4]],["bool",15]],[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[]],[[["str",15]],["option",4]],[[]],[[],["result",4]],[[]],[[],["str",15]],[[],["string",3]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],null,null,null,null,null,null,null,null,null,null,null,[[]],[[]],[[],["operator",4]],[[]],[[],["result",4]],[[["operator",4]],["bool",15]],[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[]],[[["str",15]]],[[]],[[],["result",4]],[[]],[[],["str",15]],[[],["string",3]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],null,[[["char",15],["fileindex",3]],[["result",6,["bool"]],["bool",15]]],[[["char",15],["fileindex",3]],[["result",6,["bool"]],["bool",15]]],[[["char",15],["fileindex",3]],[["result",6,["bool"]],["bool",15]]],[[["char",15],["fileindex",3]],[["result",6,["bool"]],["bool",15]]],[[["char",15],["fileindex",3]],[["result",6,["bool"]],["bool",15]]],[[["char",15],["fileindex",3]],[["result",6,["bool"]],["bool",15]]],[[["char",15],["fileindex",3]],[["result",6,["bool"]],["bool",15]]],[[["char",15],["fileindex",3]],[["result",6,["bool"]],["bool",15]]],[[],["str",15]],[[]],[[]],[[],["str",15]],[[],["token",3]],[[]],[[]],[[],["bool",15]],[[],["result",4]],null,[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[]],[[]],[[],["bool",15]],[[],["bool",15]],[[],["bool",15]],[[["tokenkind",4],["string",3],["fileindex",3]]],[[["fileindex",3]]],[[["fileindex",3]],[["result",6,["bool"]],["bool",15]]],[[["fileindex",3]],[["result",6,["bool"]],["bool",15]]],[[["fileindex",3]],[["result",6,["bool"]],["bool",15]]],[[["fileindex",3]],[["result",6,["bool"]],["bool",15]]],[[["fileindex",3]],[["result",6,["bool"]],["bool",15]]],[[],["result",4]],null,null,[[]],[[],["string",3]],null,[[],["result",4]],[[],["result",4]],[[],["typeid",3]],null,null,null,null,null,null,null,null,null,null,null,null,[[]],[[]],[[],["tokenkind",4]],[[]],[[]],[[],["result",4]],[[["tokenkind",4]],["bool",15]],[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[]],[[]],[[],["bool",15]],[[["tokenkind",4]],["bool",15]],[[],["result",4]],[[]],[[],["string",3]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,[[]],[[]],null,null,[[]],[[],["bool",15]],null,null,[[]],[[]],[[["str",15]]],[[]],[[["path",3]],["result",6]],[[]],[[],[["option",4,["error"]],["error",6]]],[[],["fileindex",3]],[[],["fileindex",3]],[[],[["char",15],["option",4,["char"]]]],null,[[]],[[]],[[]],null,[[["lines",3,["bufreader"]],["enumerate",3,["lines"]]]],[[],["option",4]],[[],["bool",15]],[[],[["char",15],["option",4,["char"]]]],[[],[["option",4,["error"]],["error",6]]],[[],["result",4]],[[["path",3]],["result",6]],[[],["result",4]],[[],["typeid",3]],null,[[]],[[]],[[]],[[]],[[["tokeniterator",3]]],[[],["result",4]],null,[[],["result",4]],[[],["result",4]],[[],["typeid",3]],null,null,null,null,null,null,[[]],[[]],[[]],[[]],[[],["lexertupleref",3]],[[]],[[]],[[]],[[]],[[]],[[]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],[[],["typeid",3]],null,[[]],[[]],[[]],[[]],[[["filestream",3]],["bool",15]],null,[[]],[[["filestream",3]],[["result",6,["token"]],["token",3]]],[[["filestream",3]],["tokeniterator",3]],[[["filestream",3]],["lexertuplemut",3]],[[["filestream",3]],["lexertupleref",3]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],null,[[]],[[]],null,[[],["bool",15]],[[]],[[]],[[]],[[],["bool",15]],[[["filestream",3],["tokenizer",3]]],[[],["option",4]],[[],[["result",6,["token"]],["token",3]]],null,[[],["lexertuplemut",3]],[[],["lexertupleref",3]],null,[[],["result",4]],[[],["result",4]],[[],["typeid",3]],[[["char",15]],["bool",15]],[[["char",15]],["bool",15]],[[["char",15]],["bool",15]],[[["char",15]],["bool",15]],[[["char",15]],["bool",15]],[[["char",15]],["bool",15]],[[["char",15]],["bool",15]],[[["char",15]],["bool",15]],[[["char",15]],["bool",15]],[[["char",15]],["bool",15]],[[["char",15]],["bool",15]],[[["char",15]],["bool",15]],[[["char",15]],["bool",15]],[[["char",15]],["bool",15]]],"p":[[4,"ErrorKind"],[4,"BracketKind"],[4,"TokenKind"],[4,"Keyword"],[4,"Operator"],[4,"BracketSide"],[3,"FileIndex"],[3,"Token"],[3,"Bracket"],[3,"LexerTupleMut"],[3,"LexerTupleRef"],[3,"FileStream"],[3,"TokenIterator"],[3,"Tokenizer"],[3,"LexerSerializer"]]},\
"kaleidoscope_logging":{"doc":"A sub-crate for handling the logging needs of this crate.","t":[0,0,5,6,4,13,13,13,6,11,11,11,11,11,11,11,11,11,11,11,11,11,11,5],"n":["error","helpers","init","Error","ErrorKind","FormatterError","LoggerError","Other","Result","borrow","borrow_mut","clone","clone_into","eq","fmt","fmt","from","into","to_owned","to_string","try_from","try_into","type_id","format_record"],"q":["kaleidoscope_logging","","","kaleidoscope_logging::error","","","","","","","","","","","","","","","","","","","","kaleidoscope_logging::helpers"],"d":["Module for error handling in this sub-crate.","Helper functions used by this crate.","Initialise the logger used by LLVMKaleidoscope. This …","The error type used by this crate.","The enum that classifies the type of error encountered by …","","","","The result type used by this crate.","","","","","","","","","","","","","","","Format a record from the logger into a string to be used …"],"i":[0,0,0,0,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],"f":[null,null,[[["option",4,["asref"]],["asref",8]],["result",6]],null,null,null,null,null,null,[[]],[[]],[[],["errorkind",4]],[[]],[[["errorkind",4]],["bool",15]],[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[]],[[]],[[]],[[],["string",3]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],[[["record",3],["formatter",3]],["result",6]]],"p":[[4,"ErrorKind"]]},\
"kaleidoscope_macro":{"doc":"Sub-crate for macros I will be using in this repo.","t":[14,14,14,14,14,14,14,14],"n":["function_name","function_path","hash_map","impl_display","iterator_to_str","ok_none","return_ok_some","untrimmed_function_path"],"q":["kaleidoscope_macro","","","","","","",""],"d":["Get the name of the function (no paths) of the current …","Get the full qualified name of the current …","Create a hash map","Implement a default version of <code>std::fmt::Display</code> for a …","Convert an iterator into a string with each element being …","Unwrap an <code>Option</code> but return <code>Ok(None)</code> if the <code>Option</code> is <code>None</code>…","If <code>$option</code> is <code>Some</code>, return <code>Ok($option)</code>.","See <code>function_path</code>."],"i":[0,0,0,0,0,0,0,0],"f":[null,null,null,null,null,null,null,null],"p":[]},\
"kaleidoscope_parser":{"doc":"The parser which uses the output from the tokenizers in …","t":[0,0,0,0,17,3,3,11,11,11,11,12,11,11,11,11,12,11,11,11,11,11,11,11,11,11,12,11,11,11,11,11,12,12,11,11,11,11,11,11,11,12,5,11,12,12,11,11,11,12,11,11,11,11,11,11,11,12,6,4,13,13,13,6,13,11,11,11,11,11,11,11,11,11,11,11,11,11,11,6,3,3,11,11,11,11,11,11,12,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,12,11,11,11,11,11,11,11,11,12,11,13,4,13,13,13,13,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11],"n":["driver","error","parser","precedence","DEFAULT_PROMPT","Driver","Interpreter","borrow","borrow","borrow_mut","borrow_mut","can_proceed","clone","clone_into","default","default","driver","fail_on_error","fmt","from","from","get_last_error","get_prompt","handle_expression","handle_extern_function","handle_function_definition","interactive","into","into","into_iter","is_done","is_interactive","istream","last_error","main_loop","main_loop","new","new","next","parse_once","parse_one","parser","parser_output_to_str","proceed_even_if_error","proceed_even_if_error","prompt","relinquish_istream","take_last_error","to_owned","tokenizer","try_from","try_from","try_into","try_into","type_id","type_id","verbosity","verbosity","Error","ErrorKind","LexerError","Other","ParsingError","Result","SyntaxError","borrow","borrow_mut","clone","clone_into","eq","fmt","fmt","from","into","to_owned","to_string","try_from","try_into","type_id","ParseResult","Parser","ParserToken","borrow","borrow","borrow_mut","borrow_mut","clone","clone_into","current_token","default","deref","find_matching_right_round_bracket","fmt","from","from","get_current_token","grab_if_used","grab_token_from_tokenizer","into","into","mark_unused","mark_used","new","new","next_token","parse_binary_operator_rhs_expression","parse_comma_expression_list","parse_expression","parse_extern_function","parse_float_expression","parse_function","parse_function_call_expression","parse_function_prototype","parse_integer_expression","parse_primary_expression","parse_round_bracket_expression","parse_top_level_expression","parse_variable_expression","peek","peek_current_token","replace","replace_used","replace_used_token","set_unused","to_owned","token","try_from","try_from","try_into","try_into","type_id","type_id","unused","use_once","uses","utilize","Addition","BinaryOperatorPrecedence","Comparison","Exponentiation","Multiplication","Unknown","borrow","borrow_mut","clone","clone_into","cmp","eq","fmt","fmt","from","from_operator","from_string","get_highest","get_lowest","into","partial_cmp","to_owned","to_string","try_from","try_into","type_id"],"q":["kaleidoscope_parser","","","","kaleidoscope_parser::driver","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","kaleidoscope_parser::error","","","","","","","","","","","","","","","","","","","","","kaleidoscope_parser::parser","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","kaleidoscope_parser::precedence","","","","","","","","","","","","","","","","","","","","","","","","",""],"d":["The structs used to parse a complete Kaleidoscope …","Error module defining the types used when handling errors …","The module defining functions to parse a given …","A module for managing the precedence of binary operators.","The default prompt used in an interactive session.","The driver that brings input from a file stream to the …","A full interpreter that can parse a programme by itself.","","","","","","","","","","","Set the policy of this interpreter to immediately …","","","","Get a reference to the last error encountered during the …","Get the prompt used by the driver if it is in interactive …","The handler function which deals with expressions.","The handler function which deals with external function …","The handler function which deals with function …","","","","","Check if there are anymore tokens in the programme.","Check whether the driver is an interactive REPL. This …","","","Parse a full Kaleidoscope programme.","Parse all the statements in a program until an EOF or an …","Create a new interpreter.","Create a new driver for parsing a Kaleidoscope programme.","","Parse one statement. If the interpreter can parse more …","Parse one statement.","","Convert the output from the <code>Parser</code> to a String.","Set the policy of this interpreter to continue parsing …","","","Get the <code>FileStream</code> used by the interpreter.","Get the last error encountered during the parsing of the …","","","","","","","","","Get the verbosity of the driver. The greater this number …","","The error type used by this parser crate.","The types of errors you may encounter in …","","","","The result type used by this parser crate.","","","","","","","","","","","","","","","","The return type of most parser functions in <code>Parser</code>.","The parser struct that converts a Kaleidoscope program …","The token manager struct that determines when a <code>Token</code> …","","","","","","","","","","Helper code that finds a right bracket that cancels out a …","","","","Get the current token being stored, marking as used in …","Pull a new token from the tokenizer and file stream if …","Replace the token with a new token from the stream and …","","","Mark the token in the manager as unused.","Mark the token in the manager as used.","Create a new parser.","Create a new <code>ParserToken</code> manager.","Replace the token the parser is currently reading with …","Parse a binary operator expression. This is similar to …","Parse a program that contains a list of expressions. Each …","Parse an expression.","Parse an extern function declaration.","Parse a float expression.","Parse a function definition.","Parse a call to a function. Such an expression comes in …","Parse a function prototype.","Parse an integer expression.","Parse a so-called “primary” expression. You can think …","Parse an expression wrapped inside 2 round brackets.","Converts an expression into an anonymous function.","Parse a variable expression.","Peek at the token currently inside. This method clones …","Peek at the current token being stored, without marking …","Replace the token in the <code>ParserToken</code> manager with a new …","Replace the token in the <code>ParserToken</code> manager with a new …","Replace the token the parser is currently reading with …","Mark the token inside as unused. However, …","","","","","","","","","Check if the <code>Token</code> stored inside has been used at least …","Increase the number of uses by one. This marks the token …","","Clone the token in the manager and mark it as used.","","An enumerator defining the precedence of each operator. …","","","","","","","","","","","","","","Get the operator precedence of an operator.","Get the operator precedence from the string version of the…","Get the precedence variant with the highest priority.","Get the precedence variant with the lowest priority.","","","","","","",""],"i":[0,0,0,0,0,0,0,1,2,1,2,1,2,2,1,2,1,1,2,1,2,1,2,2,2,2,2,1,2,1,1,2,1,1,1,2,1,2,1,1,2,1,0,1,1,2,1,1,2,1,1,2,1,2,1,2,2,2,0,0,3,3,3,0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,0,0,0,4,5,4,5,5,5,4,5,5,4,5,4,5,4,4,4,4,5,4,4,4,5,4,4,4,4,4,4,4,4,4,4,4,4,4,4,5,4,5,5,4,5,5,5,4,5,4,5,4,5,5,5,5,5,6,0,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6],"f":[null,null,null,null,null,null,null,[[]],[[]],[[]],[[]],null,[[],["driver",3]],[[]],[[]],[[]],null,[[]],[[["formatter",3]],["result",6]],[[]],[[]],[[],[["error",6],["option",4,["error"]]]],[[],["str",15]],[[["filestream",3],["tokenizer",3],["parser",3]],[["exprnode",8],["parseresult",6,["exprnode"]]]],[[["filestream",3],["tokenizer",3],["parser",3]],[["parseresult",6,["externfunctionnode"]],["externfunctionnode",3]]],[[["filestream",3],["tokenizer",3],["parser",3]],[["functionnode",3],["parseresult",6,["functionnode"]]]],null,[[]],[[]],[[]],[[],["bool",15]],[[],["bool",15]],null,null,[[],["usize",15]],[[["filestream",3],["tokenizer",3],["parser",3]],[["usize",15],["result",6,["usize"]]]],[[["u32",15],["filestream",3],["bool",15]]],[[["string",3],["u32",15],["bool",15]]],[[],["option",4]],[[["bool",15]],[["nodeenum",4],["result",4,["nodeenum","bool"]],["bool",15]]],[[["filestream",3],["tokenizer",3],["parser",3]],[["result",6,["option"]],["option",4,["nodeenum"]]]],null,[[["parseresult",6]],["string",3]],[[]],null,null,[[],["filestream",3]],[[],[["error",6],["option",4,["error"]]]],[[]],null,[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],[[],["typeid",3]],[[],["u32",15]],null,null,null,null,null,null,null,null,[[]],[[]],[[],["errorkind",4]],[[]],[[["errorkind",4]],["bool",15]],[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[]],[[]],[[]],[[],["string",3]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],null,null,null,[[]],[[]],[[]],[[]],[[],["parsertoken",3]],[[]],null,[[],["parsertoken",3]],[[]],[[["lexertuplemut",3],["fileindex",3]],[["token",3],["result",6,["token"]]]],[[["formatter",3]],["result",6]],[[]],[[]],[[],[["option",4,["token"]],["token",3]]],[[["lexertuplemut",3]],["result",6]],[[["lexertuplemut",3]],["result",6]],[[]],[[]],[[]],[[]],[[]],[[["token",3]]],[[["token",3]],["result",6]],[[["exprnode",8],["bool",15],["usize",15],["binaryoperatorprecedence",4],["lexertuplemut",3],["operator",4],["box",3,["exprnode"]]],[["exprnode",8],["parseresult",6,["exprnode"]]]],[[["lexertuplemut",3],["bracket",3]],[["result",6,["option"]],["option",4,["vec"]]]],[[["lexertuplemut",3]],[["exprnode",8],["parseresult",6,["exprnode"]]]],[[["lexertuplemut",3]],[["parseresult",6,["externfunctionnode"]],["externfunctionnode",3]]],[[["lexertuplemut",3]],[["exprnode",8],["parseresult",6,["exprnode"]]]],[[["lexertuplemut",3]],[["functionnode",3],["parseresult",6,["functionnode"]]]],[[["lexertuplemut",3]],[["exprnode",8],["parseresult",6,["exprnode"]]]],[[["lexertuplemut",3]],[["functionprototypenode",3],["parseresult",6,["functionprototypenode"]]]],[[["lexertuplemut",3]],[["exprnode",8],["parseresult",6,["exprnode"]]]],[[["lexertuplemut",3]],[["exprnode",8],["parseresult",6,["exprnode"]]]],[[["lexertuplemut",3]],[["exprnode",8],["parseresult",6,["exprnode"]]]],[[["lexertuplemut",3]],[["exprnode",8],["parseresult",6,["exprnode"]]]],[[["lexertuplemut",3]],[["exprnode",8],["parseresult",6,["exprnode"]]]],[[],[["option",4,["token"]],["token",3]]],[[],[["option",4,["token"]],["token",3]]],[[["token",3]],[["option",4,["token"]],["token",3]]],[[["token",3]],[["option",4,["token"]],["token",3]]],[[["token",3]],["result",6]],[[]],[[]],null,[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],[[],["typeid",3]],[[],["bool",15]],[[]],null,[[],[["option",4,["token"]],["token",3]]],null,null,null,null,null,null,[[]],[[]],[[],["binaryoperatorprecedence",4]],[[]],[[["binaryoperatorprecedence",4]],["ordering",4]],[[["binaryoperatorprecedence",4]],["bool",15]],[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[]],[[["operator",4]]],[[["str",15]]],[[]],[[]],[[]],[[["binaryoperatorprecedence",4]],[["option",4,["ordering"]],["ordering",4]]],[[]],[[],["string",3]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]]],"p":[[3,"Interpreter"],[3,"Driver"],[4,"ErrorKind"],[3,"Parser"],[3,"ParserToken"],[4,"BinaryOperatorPrecedence"]]},\
"kldnum":{"doc":"","t":[5],"n":["main"],"q":["kldnum"],"d":[""],"i":[0],"f":[[[]]],"p":[]},\
"repl":{"doc":"","t":[17,5,5],"n":["WELCOME_MESSAGE","main","press_enter_to_continue"],"q":["repl","",""],"d":["","",""],"i":[0,0,0],"f":[null,[[]],[[["asref",8]]]],"p":[]},\
"tokenizer":{"doc":"","t":[13,13,4,13,11,11,11,11,11,11,11,11,11,5,11,11,11,11],"n":["Debug","Json","OutputFormats","Toml","borrow","borrow_mut","clone","clone_into","eq","fmt","from","from_string","into","main","to_owned","try_from","try_into","type_id"],"q":["tokenizer","","","","","","","","","","","","","","","","",""],"d":["","","","","","","","","","","","","","","","","",""],"i":[1,1,0,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1],"f":[null,null,null,null,[[]],[[]],[[],["outputformats",4]],[[]],[[["outputformats",4]],["bool",15]],[[["formatter",3]],["result",6]],[[]],[[["str",15]],["option",4]],[[]],[[]],[[]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]]],"p":[[4,"OutputFormats"]]}\
}');
if (window.initSearch) {window.initSearch(searchIndex)};